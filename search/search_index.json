{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-form laminas-form is intended primarily as a bridge between your domain models and the View Layer. It composes a thin layer of objects representing form elements, an InputFilter, and a small number of methods for binding data to and from the form and attached objects. Installation Run the following to install this library: $ composer require laminas/laminas-form Documentation Browse the documentation online at https://docs.laminas.dev/laminas-form/ Support Issues Chat Forum","title":"Home"},{"location":"#laminas-form","text":"laminas-form is intended primarily as a bridge between your domain models and the View Layer. It composes a thin layer of objects representing form elements, an InputFilter, and a small number of methods for binding data to and from the form and attached objects.","title":"laminas-form"},{"location":"#installation","text":"Run the following to install this library: $ composer require laminas/laminas-form","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.laminas.dev/laminas-form/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"advanced/","text":"Advanced use cases Beginning with version 2.1, forms elements can be registered using a designated plugin manager, in the same way that view helpers, controller plugins, and filters are registered. This new feature has a number of benefits, especially when you need to handle complex dependencies in forms/fieldsets. Short names The first advantage of pulling form elements from the service manager is that now you can use short names to create new elements through the factory. Therefore, this code: $form-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', ]); can now be replaced by: $form-&gt;add([ 'type' =&gt; 'Email', 'name' =&gt; 'email' ]); Each element provided out-of-the-box by laminas-form supports this natively. Use the ::class constant While using aliases leads to compact code, they're also can more easily result in typographic mistakes. We recommend using the ::class constant in most situations, as these can be more easily scanned with static analysis tools for correctness. Creating custom elements laminas-form also supports custom form elements. To create a custom form element, make it extend the Laminas\\Form\\Element class, or, if you have a more specific dependency, extend one of the classes in the Laminas\\Form\\Element namespace. In the following, we will demonstrate creating a custom Phone element for entering phone numbers. It will extend Laminas\\Form\\Element class and provide some default input rules. Our custom phone element could look something like this: namespace Application\\Form\\Element; use Laminas\\Filter; use Laminas\\Form\\Element; use Laminas\\InputFilter\\InputProviderInterface; use Laminas\\Validator\\Regex as RegexValidator; class Phone extends Element implements InputProviderInterface { /** * @var ValidatorInterface */ protected $validator; /** * Get a validator if none has been set. * * @return ValidatorInterface */ public function getValidator() { if (null === $this-&gt;validator) { $validator = new RegexValidator('/^\\+?\\d{11,12}$/'); $validator-&gt;setMessage( 'Please enter 11 or 12 digits only!', RegexValidator::NOT_MATCH ); $this-&gt;validator = $validator; } return $this-&gt;validator; } /** * Sets the validator to use for this element * * @param ValidatorInterface $validator * @return self */ public function setValidator(ValidatorInterface $validator) { $this-&gt;validator = $validator; return $this; } /** * Provide default input rules for this element * * Attaches a phone number validator. * * @return array */ public function getInputSpecification() { return [ 'name' =&gt; $this-&gt;getName(), 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ], 'validators' =&gt; [ $this-&gt;getValidator(), ], ]; } } By implementing Laminas\\InputFilter\\InputProviderInterface interface, we are hinting to our form object that this element provides some default input rules for filtering and/or validating values. In this example, the default input specification provides a Laminas\\Filter\\StringTrim filter and a Laminas\\Validator\\Regex validator that validates that the value optionally has a + sign at the beginning, and is followed by 11 or 12 digits. To use the new element in our forms, we can specify it by its fully qualified class name (FQCN): use Application\\Form\\Element\\Phone; use Laminas\\Form\\Form; $form = Form(); $form-&gt;add(array( 'name' =&gt; 'phone', 'type' =&gt; Phone::class, )); Or, if you are extending Laminas\\Form\\Form : namespace Application\\Form; use Laminas\\Form\\Form; class MyForm extends Form { public function __construct($name = null) { parent::__construct($name); $this-&gt;add([ 'name' =&gt; 'phone', 'type' =&gt; Element\\Phone::class, ]); } } If you don't want to use the custom element's FQCN, but rather a short name, add an entry for it to Laminas\\Form\\FormElementManager . You can do this by adding an entry under the form_elements configuration, or within your Module class via a getFormElementConfig() method. Configuration via a config file (e.g., module.config.php ) file looks like the following: use Laminas\\ServiceManager\\Factory\\InvokableFactory; return [ 'form_elements' =&gt; [ 'aliases' =&gt; [ 'phone' =&gt; Application\\Form\\Element\\Phone::class, ], 'factories' =&gt; [ Application\\Form\\Element\\Phone::class =&gt; InvokableFactory::class, ], ], ]; The following demonstrates using your Module class: namespace Application; use Laminas\\ModuleManager\\Feature\\FormElementProviderInterface; use Laminas\\ServiceManager\\Factory\\InvokableFactory; class Module implements FormElementProviderInterface { public function getFormElementConfig() { return [ 'aliases' =&gt; [ 'phone' =&gt; Form\\Element\\Phone::class, ], 'factories' =&gt; [ Form\\Element\\Phone::class =&gt; InvokableFactory::class, ], ]; } } If needed, you can define a custom factory for handling dependencies. And now comes the first catch. If you are creating your form class by extending Laminas\\Form\\Form , you must not add the custom element in the constructor (as we have done in the previous example where we used the custom element's FQCN), but rather in the init() method: namespace Application\\Form; use Laminas\\Form\\Form; class MyForm extends Form { public function init() { $this-&gt;add([ 'name' =&gt; 'phone', 'type' =&gt; 'phone', ]); } } The second catch is that you must not directly instantiate your form class, but rather get an instance of it through Laminas\\Form\\FormElementManager : namespace Application\\Controller; use Application\\Form\\MyForm; use Laminas\\Mvc\\Controller\\AbstractActionController; class IndexController extends AbstractActionController { private $form; public function __construct(MyForm $form) { $this-&gt;form = $form; } public function indexAction() { return array('form' =&gt; $this-&gt;form); } } This now requires a factory to inject the form instance: namespace Application\\Controller; use Interop\\Container\\ContainerInterface; use Application\\Form\\MyForm; class IndexControllerFactory { public function __invoke(ContainerInterface $container) { $formManager = $container-&gt;get('FormElementManager'); return new IndexController($formManager-&gt;get(MyForm::class)); } } Which in turn requires that you map the controller to the factory: // In module.config.php return [ /* ... */ 'controllers' =&gt; [ 'factories' =&gt; [ Application\\Controller\\IndexController::class =&gt; Application\\Controller\\IndexControllerFactory::class, ], ], ]; The biggest gain of this is that you can easily override any built-in form elements if they do not fit your needs. For instance, if you want to create your own Email element instead of the standard one, create your custom element, and add it to the form element config with the same key as the element you want to replace: namespace Application; use Laminas\\Form\\Element\\Email; use Laminas\\ModuleManager\\Feature\\FormElementProviderInterface; use Laminas\\ServiceManager\\Factory\\InvokableFactory; class Module implements FormElementProviderInterface { public function getFormElementConfig() { return [ 'aliases' =&gt; [ 'email' =&gt; Form\\Element\\MyEmail::class, 'Email' =&gt; Form\\Element\\MyEmail::class, ], 'factories' =&gt; [ Form\\Element\\MyEmail::class =&gt; InvokableFactory::class, ], ]; } } Now whenever you create an element with a type of 'email', it will create the custom element instead of the built-in one. Use the original? If you want to be able to use both the built-in one and your own one, you can still provide the FQCN of the element, e.g. Laminas\\Form\\Element\\Email . In summary, to create your own form elements (or even reusable fieldsets!) and be able to use them in your form, you need to: Create your element (like you did before). Add it to the form element manager either via the form_elements configuration in your module, or by defining a getFormElementConfig() in your Module class. Make sure the custom form element is not added in the form's constructor, but rather in its init() method, or after getting an instance of the form. Retrieve your form through the form element manager instead of directly instantiating it, and inject it in your controller. Handling dependencies Dependency management can be complex. For instance, a very frequent use case is a form that creates a fieldset, but itself need access to the database to populate a Select element. Retrieving forms from the FormElementManager solves this issue, as factories it invokes have access to the application service container, and can use it to provide dependencies. For instance, let's say that a form create a fieldset called AlbumFieldset : namespace Application\\Form; use Laminas\\Form\\Form; class CreateAlbum extends Form { public function init() { $this-&gt;add([ 'name' =&gt; 'album', 'type' =&gt; AlbumFieldset::class, ]); } } Let's now create the AlbumFieldset , and have it depend on an AlbumTable object that allows us to fetch albums from the database. namespace Application\\Form; use Album\\Model\\AlbumTable; use Laminas\\Form\\Fieldset; class AlbumFieldset extends Fieldset { public function __construct(AlbumTable $albumTable) { // Add any elements that need to fetch data from database // using the album table ! } } To enable this, we'll create a factory for our AlbumFieldset as follows: namespace Application\\Form; use Album\\Model\\AlbumTable; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\FactoryInterface; use Laminas\\ServiceManager\\ServiceLocatorInterface; class AlbumFieldsetFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $name, array $options = null) { return new AlbumFieldset($container-&gt;get(AlbumTable::class)); } public function createService(ServiceLocatorInterface $formManager) { return $this( $formManager-&gt;getServiceLocator() ?: $formManager, AlbumFieldset::class ); } } Compatibility The above factory was written to work with both the v2 and v3 releases of laminas-servicemanager. If you know you will only be using v3, you can remove the createService() implementation. You can now map the fieldset to the factory in your configuration: // In module.config.php: return [ 'form_elements' =&gt; [ 'factories' =&gt; [ Application\\Form\\AlbumFieldset::class =&gt; Application\\Form\\AlbumFieldsetFactory::class, ], ], ]; Inject your form into your controller, per the example in the previous section. As a reminder, to use your fieldset in a view, you need to use the formCollection helper: echo $this-&gt;form()-&gt;openTag($form); echo $this-&gt;formCollection($form-&gt;get('album')); echo $this-&gt;form()-&gt;closeTag(); Initialization As noted in previous sections, and in the chapter on elements, we recommend defining an init() method for initializing your elements, fieldsets, and forms. Where does this come from, and when exactly is it invoked in the object lifecycle? The method is defined in Laminas\\Stdlib\\InitializableInterface , which Laminas\\Form\\Element implements. It is not , however, automatically invoked on instantiation! Within laminas-form, the FormElementManager defines an initializer that is pushed to the bottom of the initializer stack, making it the last initializer invoked. This initializer checks if the instance created implements InitializableInterface , and, if so, calls its init() method. This approach ensures that dependencies are fully injected prior to any methods you call from your init() method. As a result, when pulling items from the FormElementManager , you can be assured that all factories are correctly setup and populated, and shared across all specifications you provide.","title":"Advanced"},{"location":"advanced/#advanced-use-cases","text":"Beginning with version 2.1, forms elements can be registered using a designated plugin manager, in the same way that view helpers, controller plugins, and filters are registered. This new feature has a number of benefits, especially when you need to handle complex dependencies in forms/fieldsets.","title":"Advanced use cases"},{"location":"advanced/#short-names","text":"The first advantage of pulling form elements from the service manager is that now you can use short names to create new elements through the factory. Therefore, this code: $form-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', ]); can now be replaced by: $form-&gt;add([ 'type' =&gt; 'Email', 'name' =&gt; 'email' ]); Each element provided out-of-the-box by laminas-form supports this natively.","title":"Short names"},{"location":"advanced/#creating-custom-elements","text":"laminas-form also supports custom form elements. To create a custom form element, make it extend the Laminas\\Form\\Element class, or, if you have a more specific dependency, extend one of the classes in the Laminas\\Form\\Element namespace. In the following, we will demonstrate creating a custom Phone element for entering phone numbers. It will extend Laminas\\Form\\Element class and provide some default input rules. Our custom phone element could look something like this: namespace Application\\Form\\Element; use Laminas\\Filter; use Laminas\\Form\\Element; use Laminas\\InputFilter\\InputProviderInterface; use Laminas\\Validator\\Regex as RegexValidator; class Phone extends Element implements InputProviderInterface { /** * @var ValidatorInterface */ protected $validator; /** * Get a validator if none has been set. * * @return ValidatorInterface */ public function getValidator() { if (null === $this-&gt;validator) { $validator = new RegexValidator('/^\\+?\\d{11,12}$/'); $validator-&gt;setMessage( 'Please enter 11 or 12 digits only!', RegexValidator::NOT_MATCH ); $this-&gt;validator = $validator; } return $this-&gt;validator; } /** * Sets the validator to use for this element * * @param ValidatorInterface $validator * @return self */ public function setValidator(ValidatorInterface $validator) { $this-&gt;validator = $validator; return $this; } /** * Provide default input rules for this element * * Attaches a phone number validator. * * @return array */ public function getInputSpecification() { return [ 'name' =&gt; $this-&gt;getName(), 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ], 'validators' =&gt; [ $this-&gt;getValidator(), ], ]; } } By implementing Laminas\\InputFilter\\InputProviderInterface interface, we are hinting to our form object that this element provides some default input rules for filtering and/or validating values. In this example, the default input specification provides a Laminas\\Filter\\StringTrim filter and a Laminas\\Validator\\Regex validator that validates that the value optionally has a + sign at the beginning, and is followed by 11 or 12 digits. To use the new element in our forms, we can specify it by its fully qualified class name (FQCN): use Application\\Form\\Element\\Phone; use Laminas\\Form\\Form; $form = Form(); $form-&gt;add(array( 'name' =&gt; 'phone', 'type' =&gt; Phone::class, )); Or, if you are extending Laminas\\Form\\Form : namespace Application\\Form; use Laminas\\Form\\Form; class MyForm extends Form { public function __construct($name = null) { parent::__construct($name); $this-&gt;add([ 'name' =&gt; 'phone', 'type' =&gt; Element\\Phone::class, ]); } } If you don't want to use the custom element's FQCN, but rather a short name, add an entry for it to Laminas\\Form\\FormElementManager . You can do this by adding an entry under the form_elements configuration, or within your Module class via a getFormElementConfig() method. Configuration via a config file (e.g., module.config.php ) file looks like the following: use Laminas\\ServiceManager\\Factory\\InvokableFactory; return [ 'form_elements' =&gt; [ 'aliases' =&gt; [ 'phone' =&gt; Application\\Form\\Element\\Phone::class, ], 'factories' =&gt; [ Application\\Form\\Element\\Phone::class =&gt; InvokableFactory::class, ], ], ]; The following demonstrates using your Module class: namespace Application; use Laminas\\ModuleManager\\Feature\\FormElementProviderInterface; use Laminas\\ServiceManager\\Factory\\InvokableFactory; class Module implements FormElementProviderInterface { public function getFormElementConfig() { return [ 'aliases' =&gt; [ 'phone' =&gt; Form\\Element\\Phone::class, ], 'factories' =&gt; [ Form\\Element\\Phone::class =&gt; InvokableFactory::class, ], ]; } } If needed, you can define a custom factory for handling dependencies. And now comes the first catch. If you are creating your form class by extending Laminas\\Form\\Form , you must not add the custom element in the constructor (as we have done in the previous example where we used the custom element's FQCN), but rather in the init() method: namespace Application\\Form; use Laminas\\Form\\Form; class MyForm extends Form { public function init() { $this-&gt;add([ 'name' =&gt; 'phone', 'type' =&gt; 'phone', ]); } } The second catch is that you must not directly instantiate your form class, but rather get an instance of it through Laminas\\Form\\FormElementManager : namespace Application\\Controller; use Application\\Form\\MyForm; use Laminas\\Mvc\\Controller\\AbstractActionController; class IndexController extends AbstractActionController { private $form; public function __construct(MyForm $form) { $this-&gt;form = $form; } public function indexAction() { return array('form' =&gt; $this-&gt;form); } } This now requires a factory to inject the form instance: namespace Application\\Controller; use Interop\\Container\\ContainerInterface; use Application\\Form\\MyForm; class IndexControllerFactory { public function __invoke(ContainerInterface $container) { $formManager = $container-&gt;get('FormElementManager'); return new IndexController($formManager-&gt;get(MyForm::class)); } } Which in turn requires that you map the controller to the factory: // In module.config.php return [ /* ... */ 'controllers' =&gt; [ 'factories' =&gt; [ Application\\Controller\\IndexController::class =&gt; Application\\Controller\\IndexControllerFactory::class, ], ], ]; The biggest gain of this is that you can easily override any built-in form elements if they do not fit your needs. For instance, if you want to create your own Email element instead of the standard one, create your custom element, and add it to the form element config with the same key as the element you want to replace: namespace Application; use Laminas\\Form\\Element\\Email; use Laminas\\ModuleManager\\Feature\\FormElementProviderInterface; use Laminas\\ServiceManager\\Factory\\InvokableFactory; class Module implements FormElementProviderInterface { public function getFormElementConfig() { return [ 'aliases' =&gt; [ 'email' =&gt; Form\\Element\\MyEmail::class, 'Email' =&gt; Form\\Element\\MyEmail::class, ], 'factories' =&gt; [ Form\\Element\\MyEmail::class =&gt; InvokableFactory::class, ], ]; } } Now whenever you create an element with a type of 'email', it will create the custom element instead of the built-in one.","title":"Creating custom elements"},{"location":"advanced/#handling-dependencies","text":"Dependency management can be complex. For instance, a very frequent use case is a form that creates a fieldset, but itself need access to the database to populate a Select element. Retrieving forms from the FormElementManager solves this issue, as factories it invokes have access to the application service container, and can use it to provide dependencies. For instance, let's say that a form create a fieldset called AlbumFieldset : namespace Application\\Form; use Laminas\\Form\\Form; class CreateAlbum extends Form { public function init() { $this-&gt;add([ 'name' =&gt; 'album', 'type' =&gt; AlbumFieldset::class, ]); } } Let's now create the AlbumFieldset , and have it depend on an AlbumTable object that allows us to fetch albums from the database. namespace Application\\Form; use Album\\Model\\AlbumTable; use Laminas\\Form\\Fieldset; class AlbumFieldset extends Fieldset { public function __construct(AlbumTable $albumTable) { // Add any elements that need to fetch data from database // using the album table ! } } To enable this, we'll create a factory for our AlbumFieldset as follows: namespace Application\\Form; use Album\\Model\\AlbumTable; use Interop\\Container\\ContainerInterface; use Laminas\\ServiceManager\\FactoryInterface; use Laminas\\ServiceManager\\ServiceLocatorInterface; class AlbumFieldsetFactory implements FactoryInterface { public function __invoke(ContainerInterface $container, $name, array $options = null) { return new AlbumFieldset($container-&gt;get(AlbumTable::class)); } public function createService(ServiceLocatorInterface $formManager) { return $this( $formManager-&gt;getServiceLocator() ?: $formManager, AlbumFieldset::class ); } }","title":"Handling dependencies"},{"location":"advanced/#initialization","text":"As noted in previous sections, and in the chapter on elements, we recommend defining an init() method for initializing your elements, fieldsets, and forms. Where does this come from, and when exactly is it invoked in the object lifecycle? The method is defined in Laminas\\Stdlib\\InitializableInterface , which Laminas\\Form\\Element implements. It is not , however, automatically invoked on instantiation! Within laminas-form, the FormElementManager defines an initializer that is pushed to the bottom of the initializer stack, making it the last initializer invoked. This initializer checks if the instance created implements InitializableInterface , and, if so, calls its init() method. This approach ensures that dependencies are fully injected prior to any methods you call from your init() method. As a result, when pulling items from the FormElementManager , you can be assured that all factories are correctly setup and populated, and shared across all specifications you provide.","title":"Initialization"},{"location":"collections/","text":"Form Collections Often, fieldsets or elements in your forms will correspond to other domain objects. In some cases, they may correspond to collections of domain objects. In this latter case, in terms of user interfaces, you may want to add items dynamically in the user interface — a great example is adding tasks to a task list. This document is intended to demonstrate these features. To do so, we first need to define some domain objects that we'll be using. namespace Application\\Entity; class Product { /** * @var string */ protected $name; /** * @var int */ protected $price; /** * @var Brand */ protected $brand; /** * @var array */ protected $categories; /** * @param string $name * @return self */ public function setName($name) { $this-&gt;name = $name; return $this; } /** * @return string */ public function getName() { return $this-&gt;name; } /** * @param int $price * @return self */ public function setPrice($price) { $this-&gt;price = $price; return $this; } /** * @return int */ public function getPrice() { return $this-&gt;price; } /** * @param Brand $brand * @return self */ public function setBrand(Brand $brand) { $this-&gt;brand = $brand; return $this; } /** * @return Brand */ public function getBrand() { return $this-&gt;brand; } /** * @param Category[] $categories * @return self */ public function setCategories(array $categories) { $this-&gt;categories = $categories; return $this; } /** * @return Category[] */ public function getCategories() { return $this-&gt;categories; } } class Brand { /** * @var string */ protected $name; /** * @var string */ protected $url; /** * @param string $name * @return self */ public function setName($name) { $this-&gt;name = $name; return $this; } /** * @return string */ public function getName() { return $this-&gt;name; } /** * @param string $url * @return self */ public function setUrl($url) { $this-&gt;url = $url; return $this; } /** * @return string */ public function getUrl() { return $this-&gt;url; } } class Category { /** * @var string */ protected $name; /** * @param string $name * @return self */ public function setName($name) { $this-&gt;name = $name; return $this; } /** * @return string */ public function getName() { return $this-&gt;name; } } A Product has two scalar properties, name and price, a 1:1 relationship (one Product has one Brand ), and a 1:N relationship (one Product has many Category instances). Creating Fieldsets The first step is to create three fieldsets. Each fieldset will contain all the fields and relationships for a specific entity. Here is the Brand fieldset: namespace Application\\Form; use Application\\Entity\\Brand; use Laminas\\Form\\Element; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class BrandFieldset extends Fieldset implements InputFilterProviderInterface { public function __construct() { parent::__construct('brand'); $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setObject(new Brand()); $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Name of the brand', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); $this-&gt;add([ 'name' =&gt; 'url', 'type' =&gt; Element\\Url::class, 'options' =&gt; [ 'label' =&gt; 'Website of the brand', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); } /** * @return array */ public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, ], ]; } } The fieldset calls the method setHydrator() , giving it a ClassMethods hydrator, and the setObject() method, giving it an empty Brand instance. When we validate incoming data, the form will automatically iterate through all the fieldsets it contains populate all sub-objects, in order to return a complete entity. Notice that the Url element has a type of Laminas\\Form\\Element\\Url . This information will be used to validate the input field. You don't need to manually add filters or validators for this input as that element provides a reasonable input specification. Finally, getInputFilterSpecification() gives the specification for the remaining input (\"name\"), indicating that this input is required. Note that required in the array \"attributes\" (when elements are added) is only meant to add the \"required\" attribute to the form markup (and therefore has semantic meaning only). Here is the Category fieldset: namespace Application\\Form; use Application\\Entity\\Category; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class CategoryFieldset extends Fieldset implements InputFilterProviderInterface { public function __construct() { parent::__construct('category'); $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setObject(new Category()); $this-&gt;setLabel('Category'); $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Name of the category', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); } /** * @return array */ public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, ], ]; } } Nothing new here. Finally, the Product fieldset: namespace Application\\Form; use Application\\Entity\\Product; use Laminas\\Form\\Element; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class ProductFieldset extends Fieldset implements InputFilterProviderInterface { public function __construct() { parent::__construct('product'); $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setObject(new Product()); $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Name of the product', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); $this-&gt;add([ 'name' =&gt; 'price', 'options' =&gt; [ 'label' =&gt; 'Price of the product', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); $this-&gt;add([ 'type' =&gt; BrandFieldset::class, 'name' =&gt; 'brand', 'options' =&gt; [ 'label' =&gt; 'Brand of the product', ], ]); $this-&gt;add([ 'type' =&gt; Element\\Collection::class, 'name' =&gt; 'categories', 'options' =&gt; [ 'label' =&gt; 'Please choose categories for this product', 'count' =&gt; 2, 'should_create_template' =&gt; true, 'allow_add' =&gt; true, 'target_element' =&gt; [ 'type' =&gt; CategoryFieldset::class, ], ], ]); } /** * Should return an array specification compatible with * {@link Laminas\\InputFilter\\Factory::createInputFilter()}. * * @return array */ public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, ], 'price' =&gt; [ 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; 'Float', ], ], ], ]; } } We have a lot of new things here! First, notice how the brand element is added: we specify it to be of type Application\\Form\\BrandFieldset . This is how you handle a 1:1 relationship. When the form is validated, the BrandFieldset will first be populated, and will return a Brand entity (as we have specified a ClassMethods hydrator, and bound the fieldset to a Brand entity using the setObject() method). This Brand entity will then be used to populate the Product entity by calling the setBrand() method. The next element shows you how to handle 1:N relationships. The type is Laminas\\Form\\Element\\Collection , which is a specialized element to handle such cases. As you can see, the name of the element (\"categories\") perfectly matches the name of the property in the Product entity. This element has a few interesting options: count : this is how many times the element (in this case, a category) has to be rendered. We've set it to 2 in this example. should_create_template : if set to true , it will generate a template markup in a &lt;span&gt; element, in order to simplify adding new element on the fly (we will speak about this one later). allow_add : if set to true (which is the default), dynamically added elements will be retrieved and validated; otherwise, they will be completely ignored. This, of course, depends on what you want to do. target_element : this is either an element or, as this is the case in this example, an array that describes the element or fieldset that will be used in the collection. In this case, the target_element is a Category fieldset. The Form Element So far, so good. We now have our fieldsets in place. But those are fieldsets, not forms. And only Form instances can be validated. So here is the form: namespace Application\\Form; use Laminas\\Form\\Element; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class CreateProduct extends Form { public function __construct() { parent::__construct('create_product'); $this-&gt;setAttribute('method', 'post') $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setInputFilter(new InputFilter()); $this-&gt;add([ 'type' =&gt; ProductFieldset::class, 'options' =&gt; [ 'use_as_base_fieldset' =&gt; true, ], ]); $this-&gt;add([ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'csrf', ]); $this-&gt;add([ 'name' =&gt; 'submit', 'attributes' =&gt; [ 'type' =&gt; 'submit', 'value' =&gt; 'Send', ], ]); } } CreateProduct only defines a Product fieldset, as well as some other useful fields ( CSRF for security, and a Submit button). Notice the use_as_base_fieldset option. This option is here to say to the form: \"hey, the object I bind to you is, in fact, bound to the fieldset that is the base fieldset.\" This will be to true in most situations. This approach allows each entity to have its own Fieldset , and enables re-use. You describe the elements, the filters, and validators for each entity only once, and the concrete Form instance will only compose those fieldsets. You no longer have to add the \"username\" input to every form that deals with users! Integrating with laminas-mvc Now, let's create a laminas-mvc controller action: /** * @return array */ public function indexAction() { $form = new CreateProduct(); $product = new Product(); $form-&gt;bind($product); $request = $this-&gt;getRequest(); if ($request-&gt;isPost()) { $form-&gt;setData($request-&gt;getPost()); if ($form-&gt;isValid()) { var_dump($product); } } return [ 'form' =&gt; $form, ]; } All the controller does is: Create a form instance. Bind it to an object. Validate it and/or return the form instance for later use by the view. Integration with laminas-view And finally, the view: &lt;?php $form-&gt;setAttribute('action', $this-&gt;url('home')); $form-&gt;prepare(); echo $this-&gt;form()-&gt;openTag($form); $product = $form-&gt;get('product'); // The name and price can be rendered as regular elements: echo $this-&gt;formRow($product-&gt;get('name')); echo $this-&gt;formRow($product-&gt;get('price')); // Categories are rendered as a collection: echo $this-&gt;formCollection($product-&gt;get('categories')); $brand = $product-&gt;get('brand'); // Since the brand is a 1:1 relationship, its elements are rendered normally: echo $this-&gt;formRow($brand-&gt;get('name')); echo $this-&gt;formRow($brand-&gt;get('url')); // And finally, we render the CSRF and submit elements: echo $this-&gt;formHidden($form-&gt;get('csrf')); echo $this-&gt;formElement($form-&gt;get('submit')); echo $this-&gt;form()-&gt;closeTag(); A few new things here : the prepare() method. You must call it prior to rendering anything in the view (this function is only meant to be called in views, not in controllers). the FormRow helper renders a label (if present), the input itself, and errors. the FormCollection helper will iterate through every element in the collection, and render every element with the FormRow helper (you may specify an alternate helper if desired, using the setElementHelper() method on that FormCollection helper instance). If you need more control about the way you render your forms, you can iterate through the elements in the collection, and render them manually one by one. Here is the result: Collections are wrapped inside a fieldset, and every item in the collection is itself wrapped in the fieldset. In fact, the Collection element uses label for each item in the collection, while the label of the Collection element itself is used as the legend of the fieldset . You must have a label on every element in order to use this feature. If you don't want the fieldset created, but just the elements within it, add a boolean false as the second parameter of the FormCollection view helper. If you validate, all elements will show errors (this is normal, as we've marked them as required). As soon as the form is valid, this is what we get : The bound object is completely filled with the object instances we specified, not with arrays! Adding New Elements Dynamically Remember that should_create_template flag? We're going to use it now. Often, forms are not completely static. In our case, let's say that we don't want only two categories, but we want the user to be able to add more at runtime. laminas-form enables this capability. First, let's see what it generates when we ask it to create a template: The collection generates two fieldsets (the two categories) plus a span with a data-template attribute that contains the full HTML code to copy to create a new element in the collection. The value __index__ (this is the placeholder generated) must be changed to a valid value. Currently, we have 2 elements ( categories[0] and categories[1] , so __index__ must be changed to 2. If you want, this placeholder ( __index__ is the default) can be changed using the template_placeholder option key: $this-&gt;add([ 'type' =&gt; Element\\Collection::class, 'name' =&gt; 'categories', 'options' =&gt; [ 'label' =&gt; 'Please choose categories for this product', 'count' =&gt; 2, 'should_create_template' =&gt; true, 'template_placeholder' =&gt; '__placeholder__', 'target_element' =&gt; [ 'type' =&gt; CategoryFieldset::class, ], ], ]); First, let's add a small button \"Add new category\" anywhere in the form: &lt;button onclick=\"return add_category()\"&gt;Add a new category&lt;/button&gt; The add_category function will need to do the following: First, count the number of elements we already have. Get the template from the span 's data-template attribute. Change the placeholder to a valid index. Add the element to the DOM. The following is a potential implementation: function add_category() { var currentCount = $('form &gt; fieldset &gt; fieldset').length; var template = $('form &gt; fieldset &gt; span').data('template'); template = template.replace(/__index__/g, currentCount); $('form &gt; fieldset').append(template); return false; } (Note: the above example assumes $() is defined, and equivalent to jQuery's $() function, Dojo's dojo.query , etc.) One small remark about template.replace : the example uses currentCount and not currentCount + 1 , as the indices are zero-based (so, if we have two elements in the + collection, the third one will have the index 2 ). Now if we validate the form, it will automatically take into account this new element by validating it, filtering it and retrieving it: If you don't want to allow adding elements in a collection, you must set the option allow_add to false . This way, even if new elements are added, they won't be validated and hence, not added to the entity. Also, if we don't want elements to be added, we don't need the data template, either. Here's how you both disable adding dynamic elements, and disable the template: $this-&gt;add([ 'type' =&gt; Element\\Collection::class, 'name' =&gt; 'categories', 'options' =&gt; [ 'label' =&gt; 'Please choose categories for this product', 'count' =&gt; 2, // Do not allow adding: 'allow_add' =&gt; false, // Do not display the index template: 'should_create_template' =&gt; false, 'target_element' =&gt; [ 'type' =&gt; CategoryFieldset::class, ], ], ]); There are some limitations to this capability: Although you can add new elements and remove them, you CANNOT remove more elements in a collection than the initial count (for instance, if your code specifies count == 2 , you will be able to add a third one and remove it, but you won't be able to remove any others. If the initial count is 2, you must have at least two elements. Dynamically added elements have to be added at the end of the collection. They can be added anywhere (these elements will still be validated and inserted into the entity), but if the validation fails, this newly added element will be automatically placed at the end of the collection. Validation groups for fieldsets and collection Validation groups allow you to validate a subset of fields. As an example, although the Brand entity has a url property, we don't want the user to specify it in the creation form (but may wish to later in the \"Edit Product\" form, for instance). Let's update the view to remove the url input: &lt;?php $form-&gt;setAttribute('action', $this-&gt;url('home')); $form-&gt;prepare(); echo $this-&gt;form()-&gt;openTag($form); $product = $form-&gt;get('product'); echo $this-&gt;formRow($product-&gt;get('name')); echo $this-&gt;formRow($product-&gt;get('price')); echo $this-&gt;formCollection($product-&gt;get('categories')); $brand = $product-&gt;get('brand'); echo $this-&gt;formRow($brand-&gt;get('name')); echo $this-&gt;formHidden($form-&gt;get('csrf')); echo $this-&gt;formElement($form-&gt;get('submit')); echo $this-&gt;form()-&gt;closeTag(); This is what we get: The url input has disappeared, but even if we fill every input, the form won't validate. In fact, this is normal. We specified in the input filter that the url is a required field, so if the form does not have it, it won't validate, even though we didn't add it to the view! Of course, you could create a BrandFieldsetWithoutUrl fieldset, but this would require a lot of duplicate code. The solution: validation groups. A validation group is specified in a Form object (hence, in our case, in the CreateProduct form) by giving an array of all the elements we want to validate. Our CreateProduct class now looks like this: namespace Application\\Form; use Laminas\\Form\\Element; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class CreateProduct extends Form { public function __construct() { parent::__construct('create_product'); $this-&gt;setAttribute('method', 'post'); $this-&gt;setHydrator(new ClassMethodsHydrator()); $this-&gt;setInputFilter(new InputFilter()); $this-&gt;add([ 'type' =&gt; ProductFieldset::class, 'options' =&gt; [ 'use_as_base_fieldset' =&gt; true, ], ]); $this-&gt;add([ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'csrf', ]); $this-&gt;add([ 'name' =&gt; 'submit', 'attributes' =&gt; [ 'type' =&gt; 'submit', 'value' =&gt; 'Send', ], ]); $this-&gt;setValidationGroup([ 'csrf', 'product' =&gt; [ 'name', 'price', 'brand' =&gt; [ 'name', ], 'categories' =&gt; [ 'name', ], ], ]); } } Don't forget to add the CSRF element, as we want it to be validated too (but notice that the example omits the submit element, as we don't care about its value). You can also recursively select the elements if desired. There is one limitation currently: validation groups for collections are set on a per-collection basis, not per-element in a collection basis. This means you cannot say, \"validate the name input for the first element of the categories collection, but don't validate it for the second one.\" Now, the form validates (and the url is set to null as we didn't specify it). Preventing validation from wiping out previous collection items In some cases, you may be representing collections within a model, but not validating them; as an example, if you use a validation group that excludes the collections from validation so that they remain untouched after binding. Starting in 2.8.4, behavior around collections changed in order to fix some underlying bugs. One such change is that if a collection is found in a form, but has no associated data, an empty array is assigned to it, even when not in the validation group. This effectively wipes out the collection data when you bind values. To prevent this behavior, starting in 2.9.1 you may pass an optional second argument to bindValues() on either a fieldset or collection, $validationGroup ; when present, these instances will first check if the collection is in the validation group before binding the value; if it is not, the collection will not be represented. The Form class has been updated to pass the validation group, if present, on to fieldset and collection instances when performing bindValues() operations. For more details, refer to the following issues: zendframework/zend-form#19 zendframework/zend-form#102 zendframework/zend-form#103 zendframework/zend-form#106","title":"Collections"},{"location":"collections/#form-collections","text":"Often, fieldsets or elements in your forms will correspond to other domain objects. In some cases, they may correspond to collections of domain objects. In this latter case, in terms of user interfaces, you may want to add items dynamically in the user interface — a great example is adding tasks to a task list. This document is intended to demonstrate these features. To do so, we first need to define some domain objects that we'll be using. namespace Application\\Entity; class Product { /** * @var string */ protected $name; /** * @var int */ protected $price; /** * @var Brand */ protected $brand; /** * @var array */ protected $categories; /** * @param string $name * @return self */ public function setName($name) { $this-&gt;name = $name; return $this; } /** * @return string */ public function getName() { return $this-&gt;name; } /** * @param int $price * @return self */ public function setPrice($price) { $this-&gt;price = $price; return $this; } /** * @return int */ public function getPrice() { return $this-&gt;price; } /** * @param Brand $brand * @return self */ public function setBrand(Brand $brand) { $this-&gt;brand = $brand; return $this; } /** * @return Brand */ public function getBrand() { return $this-&gt;brand; } /** * @param Category[] $categories * @return self */ public function setCategories(array $categories) { $this-&gt;categories = $categories; return $this; } /** * @return Category[] */ public function getCategories() { return $this-&gt;categories; } } class Brand { /** * @var string */ protected $name; /** * @var string */ protected $url; /** * @param string $name * @return self */ public function setName($name) { $this-&gt;name = $name; return $this; } /** * @return string */ public function getName() { return $this-&gt;name; } /** * @param string $url * @return self */ public function setUrl($url) { $this-&gt;url = $url; return $this; } /** * @return string */ public function getUrl() { return $this-&gt;url; } } class Category { /** * @var string */ protected $name; /** * @param string $name * @return self */ public function setName($name) { $this-&gt;name = $name; return $this; } /** * @return string */ public function getName() { return $this-&gt;name; } } A Product has two scalar properties, name and price, a 1:1 relationship (one Product has one Brand ), and a 1:N relationship (one Product has many Category instances).","title":"Form Collections"},{"location":"collections/#creating-fieldsets","text":"The first step is to create three fieldsets. Each fieldset will contain all the fields and relationships for a specific entity. Here is the Brand fieldset: namespace Application\\Form; use Application\\Entity\\Brand; use Laminas\\Form\\Element; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class BrandFieldset extends Fieldset implements InputFilterProviderInterface { public function __construct() { parent::__construct('brand'); $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setObject(new Brand()); $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Name of the brand', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); $this-&gt;add([ 'name' =&gt; 'url', 'type' =&gt; Element\\Url::class, 'options' =&gt; [ 'label' =&gt; 'Website of the brand', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); } /** * @return array */ public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, ], ]; } } The fieldset calls the method setHydrator() , giving it a ClassMethods hydrator, and the setObject() method, giving it an empty Brand instance. When we validate incoming data, the form will automatically iterate through all the fieldsets it contains populate all sub-objects, in order to return a complete entity. Notice that the Url element has a type of Laminas\\Form\\Element\\Url . This information will be used to validate the input field. You don't need to manually add filters or validators for this input as that element provides a reasonable input specification. Finally, getInputFilterSpecification() gives the specification for the remaining input (\"name\"), indicating that this input is required. Note that required in the array \"attributes\" (when elements are added) is only meant to add the \"required\" attribute to the form markup (and therefore has semantic meaning only). Here is the Category fieldset: namespace Application\\Form; use Application\\Entity\\Category; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class CategoryFieldset extends Fieldset implements InputFilterProviderInterface { public function __construct() { parent::__construct('category'); $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setObject(new Category()); $this-&gt;setLabel('Category'); $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Name of the category', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); } /** * @return array */ public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, ], ]; } } Nothing new here. Finally, the Product fieldset: namespace Application\\Form; use Application\\Entity\\Product; use Laminas\\Form\\Element; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class ProductFieldset extends Fieldset implements InputFilterProviderInterface { public function __construct() { parent::__construct('product'); $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setObject(new Product()); $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Name of the product', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); $this-&gt;add([ 'name' =&gt; 'price', 'options' =&gt; [ 'label' =&gt; 'Price of the product', ], 'attributes' =&gt; [ 'required' =&gt; 'required', ], ]); $this-&gt;add([ 'type' =&gt; BrandFieldset::class, 'name' =&gt; 'brand', 'options' =&gt; [ 'label' =&gt; 'Brand of the product', ], ]); $this-&gt;add([ 'type' =&gt; Element\\Collection::class, 'name' =&gt; 'categories', 'options' =&gt; [ 'label' =&gt; 'Please choose categories for this product', 'count' =&gt; 2, 'should_create_template' =&gt; true, 'allow_add' =&gt; true, 'target_element' =&gt; [ 'type' =&gt; CategoryFieldset::class, ], ], ]); } /** * Should return an array specification compatible with * {@link Laminas\\InputFilter\\Factory::createInputFilter()}. * * @return array */ public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, ], 'price' =&gt; [ 'required' =&gt; true, 'validators' =&gt; [ [ 'name' =&gt; 'Float', ], ], ], ]; } } We have a lot of new things here! First, notice how the brand element is added: we specify it to be of type Application\\Form\\BrandFieldset . This is how you handle a 1:1 relationship. When the form is validated, the BrandFieldset will first be populated, and will return a Brand entity (as we have specified a ClassMethods hydrator, and bound the fieldset to a Brand entity using the setObject() method). This Brand entity will then be used to populate the Product entity by calling the setBrand() method. The next element shows you how to handle 1:N relationships. The type is Laminas\\Form\\Element\\Collection , which is a specialized element to handle such cases. As you can see, the name of the element (\"categories\") perfectly matches the name of the property in the Product entity. This element has a few interesting options: count : this is how many times the element (in this case, a category) has to be rendered. We've set it to 2 in this example. should_create_template : if set to true , it will generate a template markup in a &lt;span&gt; element, in order to simplify adding new element on the fly (we will speak about this one later). allow_add : if set to true (which is the default), dynamically added elements will be retrieved and validated; otherwise, they will be completely ignored. This, of course, depends on what you want to do. target_element : this is either an element or, as this is the case in this example, an array that describes the element or fieldset that will be used in the collection. In this case, the target_element is a Category fieldset.","title":"Creating Fieldsets"},{"location":"collections/#the-form-element","text":"So far, so good. We now have our fieldsets in place. But those are fieldsets, not forms. And only Form instances can be validated. So here is the form: namespace Application\\Form; use Laminas\\Form\\Element; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class CreateProduct extends Form { public function __construct() { parent::__construct('create_product'); $this-&gt;setAttribute('method', 'post') $this-&gt;setHydrator(new ClassMethodsHydrator(false)); $this-&gt;setInputFilter(new InputFilter()); $this-&gt;add([ 'type' =&gt; ProductFieldset::class, 'options' =&gt; [ 'use_as_base_fieldset' =&gt; true, ], ]); $this-&gt;add([ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'csrf', ]); $this-&gt;add([ 'name' =&gt; 'submit', 'attributes' =&gt; [ 'type' =&gt; 'submit', 'value' =&gt; 'Send', ], ]); } } CreateProduct only defines a Product fieldset, as well as some other useful fields ( CSRF for security, and a Submit button). Notice the use_as_base_fieldset option. This option is here to say to the form: \"hey, the object I bind to you is, in fact, bound to the fieldset that is the base fieldset.\" This will be to true in most situations. This approach allows each entity to have its own Fieldset , and enables re-use. You describe the elements, the filters, and validators for each entity only once, and the concrete Form instance will only compose those fieldsets. You no longer have to add the \"username\" input to every form that deals with users!","title":"The Form Element"},{"location":"collections/#integrating-with-laminas-mvc","text":"Now, let's create a laminas-mvc controller action: /** * @return array */ public function indexAction() { $form = new CreateProduct(); $product = new Product(); $form-&gt;bind($product); $request = $this-&gt;getRequest(); if ($request-&gt;isPost()) { $form-&gt;setData($request-&gt;getPost()); if ($form-&gt;isValid()) { var_dump($product); } } return [ 'form' =&gt; $form, ]; } All the controller does is: Create a form instance. Bind it to an object. Validate it and/or return the form instance for later use by the view.","title":"Integrating with laminas-mvc"},{"location":"collections/#integration-with-laminas-view","text":"And finally, the view: &lt;?php $form-&gt;setAttribute('action', $this-&gt;url('home')); $form-&gt;prepare(); echo $this-&gt;form()-&gt;openTag($form); $product = $form-&gt;get('product'); // The name and price can be rendered as regular elements: echo $this-&gt;formRow($product-&gt;get('name')); echo $this-&gt;formRow($product-&gt;get('price')); // Categories are rendered as a collection: echo $this-&gt;formCollection($product-&gt;get('categories')); $brand = $product-&gt;get('brand'); // Since the brand is a 1:1 relationship, its elements are rendered normally: echo $this-&gt;formRow($brand-&gt;get('name')); echo $this-&gt;formRow($brand-&gt;get('url')); // And finally, we render the CSRF and submit elements: echo $this-&gt;formHidden($form-&gt;get('csrf')); echo $this-&gt;formElement($form-&gt;get('submit')); echo $this-&gt;form()-&gt;closeTag(); A few new things here : the prepare() method. You must call it prior to rendering anything in the view (this function is only meant to be called in views, not in controllers). the FormRow helper renders a label (if present), the input itself, and errors. the FormCollection helper will iterate through every element in the collection, and render every element with the FormRow helper (you may specify an alternate helper if desired, using the setElementHelper() method on that FormCollection helper instance). If you need more control about the way you render your forms, you can iterate through the elements in the collection, and render them manually one by one. Here is the result: Collections are wrapped inside a fieldset, and every item in the collection is itself wrapped in the fieldset. In fact, the Collection element uses label for each item in the collection, while the label of the Collection element itself is used as the legend of the fieldset . You must have a label on every element in order to use this feature. If you don't want the fieldset created, but just the elements within it, add a boolean false as the second parameter of the FormCollection view helper. If you validate, all elements will show errors (this is normal, as we've marked them as required). As soon as the form is valid, this is what we get : The bound object is completely filled with the object instances we specified, not with arrays!","title":"Integration with laminas-view"},{"location":"collections/#adding-new-elements-dynamically","text":"Remember that should_create_template flag? We're going to use it now. Often, forms are not completely static. In our case, let's say that we don't want only two categories, but we want the user to be able to add more at runtime. laminas-form enables this capability. First, let's see what it generates when we ask it to create a template: The collection generates two fieldsets (the two categories) plus a span with a data-template attribute that contains the full HTML code to copy to create a new element in the collection. The value __index__ (this is the placeholder generated) must be changed to a valid value. Currently, we have 2 elements ( categories[0] and categories[1] , so __index__ must be changed to 2. If you want, this placeholder ( __index__ is the default) can be changed using the template_placeholder option key: $this-&gt;add([ 'type' =&gt; Element\\Collection::class, 'name' =&gt; 'categories', 'options' =&gt; [ 'label' =&gt; 'Please choose categories for this product', 'count' =&gt; 2, 'should_create_template' =&gt; true, 'template_placeholder' =&gt; '__placeholder__', 'target_element' =&gt; [ 'type' =&gt; CategoryFieldset::class, ], ], ]); First, let's add a small button \"Add new category\" anywhere in the form: &lt;button onclick=\"return add_category()\"&gt;Add a new category&lt;/button&gt; The add_category function will need to do the following: First, count the number of elements we already have. Get the template from the span 's data-template attribute. Change the placeholder to a valid index. Add the element to the DOM. The following is a potential implementation: function add_category() { var currentCount = $('form &gt; fieldset &gt; fieldset').length; var template = $('form &gt; fieldset &gt; span').data('template'); template = template.replace(/__index__/g, currentCount); $('form &gt; fieldset').append(template); return false; } (Note: the above example assumes $() is defined, and equivalent to jQuery's $() function, Dojo's dojo.query , etc.) One small remark about template.replace : the example uses currentCount and not currentCount + 1 , as the indices are zero-based (so, if we have two elements in the + collection, the third one will have the index 2 ). Now if we validate the form, it will automatically take into account this new element by validating it, filtering it and retrieving it: If you don't want to allow adding elements in a collection, you must set the option allow_add to false . This way, even if new elements are added, they won't be validated and hence, not added to the entity. Also, if we don't want elements to be added, we don't need the data template, either. Here's how you both disable adding dynamic elements, and disable the template: $this-&gt;add([ 'type' =&gt; Element\\Collection::class, 'name' =&gt; 'categories', 'options' =&gt; [ 'label' =&gt; 'Please choose categories for this product', 'count' =&gt; 2, // Do not allow adding: 'allow_add' =&gt; false, // Do not display the index template: 'should_create_template' =&gt; false, 'target_element' =&gt; [ 'type' =&gt; CategoryFieldset::class, ], ], ]); There are some limitations to this capability: Although you can add new elements and remove them, you CANNOT remove more elements in a collection than the initial count (for instance, if your code specifies count == 2 , you will be able to add a third one and remove it, but you won't be able to remove any others. If the initial count is 2, you must have at least two elements. Dynamically added elements have to be added at the end of the collection. They can be added anywhere (these elements will still be validated and inserted into the entity), but if the validation fails, this newly added element will be automatically placed at the end of the collection.","title":"Adding New Elements Dynamically"},{"location":"collections/#validation-groups-for-fieldsets-and-collection","text":"Validation groups allow you to validate a subset of fields. As an example, although the Brand entity has a url property, we don't want the user to specify it in the creation form (but may wish to later in the \"Edit Product\" form, for instance). Let's update the view to remove the url input: &lt;?php $form-&gt;setAttribute('action', $this-&gt;url('home')); $form-&gt;prepare(); echo $this-&gt;form()-&gt;openTag($form); $product = $form-&gt;get('product'); echo $this-&gt;formRow($product-&gt;get('name')); echo $this-&gt;formRow($product-&gt;get('price')); echo $this-&gt;formCollection($product-&gt;get('categories')); $brand = $product-&gt;get('brand'); echo $this-&gt;formRow($brand-&gt;get('name')); echo $this-&gt;formHidden($form-&gt;get('csrf')); echo $this-&gt;formElement($form-&gt;get('submit')); echo $this-&gt;form()-&gt;closeTag(); This is what we get: The url input has disappeared, but even if we fill every input, the form won't validate. In fact, this is normal. We specified in the input filter that the url is a required field, so if the form does not have it, it won't validate, even though we didn't add it to the view! Of course, you could create a BrandFieldsetWithoutUrl fieldset, but this would require a lot of duplicate code. The solution: validation groups. A validation group is specified in a Form object (hence, in our case, in the CreateProduct form) by giving an array of all the elements we want to validate. Our CreateProduct class now looks like this: namespace Application\\Form; use Laminas\\Form\\Element; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilter; use Laminas\\Hydrator\\ClassMethods as ClassMethodsHydrator; class CreateProduct extends Form { public function __construct() { parent::__construct('create_product'); $this-&gt;setAttribute('method', 'post'); $this-&gt;setHydrator(new ClassMethodsHydrator()); $this-&gt;setInputFilter(new InputFilter()); $this-&gt;add([ 'type' =&gt; ProductFieldset::class, 'options' =&gt; [ 'use_as_base_fieldset' =&gt; true, ], ]); $this-&gt;add([ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'csrf', ]); $this-&gt;add([ 'name' =&gt; 'submit', 'attributes' =&gt; [ 'type' =&gt; 'submit', 'value' =&gt; 'Send', ], ]); $this-&gt;setValidationGroup([ 'csrf', 'product' =&gt; [ 'name', 'price', 'brand' =&gt; [ 'name', ], 'categories' =&gt; [ 'name', ], ], ]); } } Don't forget to add the CSRF element, as we want it to be validated too (but notice that the example omits the submit element, as we don't care about its value). You can also recursively select the elements if desired. There is one limitation currently: validation groups for collections are set on a per-collection basis, not per-element in a collection basis. This means you cannot say, \"validate the name input for the first element of the categories collection, but don't validate it for the second one.\" Now, the form validates (and the url is set to null as we didn't specify it).","title":"Validation groups for fieldsets and collection"},{"location":"collections/#preventing-validation-from-wiping-out-previous-collection-items","text":"In some cases, you may be representing collections within a model, but not validating them; as an example, if you use a validation group that excludes the collections from validation so that they remain untouched after binding. Starting in 2.8.4, behavior around collections changed in order to fix some underlying bugs. One such change is that if a collection is found in a form, but has no associated data, an empty array is assigned to it, even when not in the validation group. This effectively wipes out the collection data when you bind values. To prevent this behavior, starting in 2.9.1 you may pass an optional second argument to bindValues() on either a fieldset or collection, $validationGroup ; when present, these instances will first check if the collection is in the validation group before binding the value; if it is not, the collection will not be represented. The Form class has been updated to pass the validation group, if present, on to fieldset and collection instances when performing bindValues() operations. For more details, refer to the following issues: zendframework/zend-form#19 zendframework/zend-form#102 zendframework/zend-form#103 zendframework/zend-form#106","title":"Preventing validation from wiping out previous collection items"},{"location":"file-upload/","text":"File Uploads laminas-form provides support for file uploading by using features from each of laminas-inputfilter , laminas-validator , laminas-filter , and laminas-progressbar . These reusable framework components provide a convenient and secure way for handling file uploads in your projects. Limited to POST uploads The file upload features described here are specifically for forms using the POST method. laminas-form does not currently provide specific support for handling uploads via the PUT method, but it is possible with vanilla PHP. See the PUT Method Support in the PHP documentation for more information. Basic Example Handling file uploads is essentially the same as how you would use Laminas\\Form for form processing, but with some slight caveats that will be described below. In this example we will: Define a Form for backend validation and filtering. Create a view template with a &lt;form&gt; containing a file input. Process the form within a Controller action (laminas-mvc) or in a Request Handler (Mezzio). The Form and InputFilter Here we define a Laminas\\Form\\Element\\File input in a Form extension named UploadForm . use Laminas\\Form\\Element; use Laminas\\Form\\Form; class UploadForm extends Form { public function __construct($name = null, $options = []) { parent::__construct($name, $options); $this-&gt;addElements(); } public function addElements() { // File Input $file = new Element\\File('image-file'); $file-&gt;setLabel('Avatar Image Upload'); $file-&gt;setAttribute('id', 'image-file'); $this-&gt;add($file); } } The File element provides several automated features: The form's enctype will automatically be set to multipart/form-data when the form's prepare() method is called. The file element's default input specification will create the correct Input type: Laminas\\InputFilter\\FileInput . The FileInput will automatically prepend an UploadFile validator to securely validate that the file is actually an uploaded file, and to report any upload errors to the user. The View Template In the view template, we render the &lt;form&gt; , a file input (with label and errors), and a submit button. &lt;!-- File: upload-form.phtml --&gt; &lt;?php $form-&gt;prepare(); // The correct enctype is set here $fileElement = $form-&gt;get('image-file'); echo $this-&gt;form()-&gt;openTag($form); ?&gt; &lt;div class=\"form-element\"&gt; &lt;?= $this-&gt;formLabel($fileElement) ?&gt; &lt;?= $this-&gt;formFile($fileElement) ?&gt; &lt;?= $this-&gt;formElementErrors($fileElement) ?&gt; &lt;/div&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;?= $this-&gt;form()-&gt;closeTag() ?&gt; When rendered, the HTML should look similar to: &lt;form name=\"upload-form\" id=\"upload-form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"form-element\"&gt; &lt;label for=\"image-file\"&gt;Avatar Image Upload&lt;/label&gt; &lt;input type=\"file\" name=\"image-file\" id=\"image-file\"&gt; &lt;/div&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/form&gt; The Controller Action When using laminas-mvc, the final step will be to instantiate the UploadForm and process any postbacks in a controller action. The form processing in the controller action will be similar to normal forms, except that you must merge the $_FILES information in the request with the other post data. public function uploadFormAction() { $form = new UploadForm('upload-form'); $request = $this-&gt;getRequest(); if ($request-&gt;isPost()) { // Make certain to merge the $_FILES info! $post = array_merge_recursive( $request-&gt;getPost()-&gt;toArray(), $request-&gt;getFiles()-&gt;toArray() ); $form-&gt;setData($post); if ($form-&gt;isValid()) { $data = $form-&gt;getData(); // Form is valid, save the form! return $this-&gt;redirect()-&gt;toRoute('upload-form/success'); } } return ['form' =&gt; $form]; } Upon a successful file upload, $form-&gt;getData() would return: array(1) { [\"image-file\"] =&gt; array(5) { [\"name\"] =&gt; string(11) \"myimage.png\" [\"type\"] =&gt; string(9) \"image/png\" [\"tmp_name\"] =&gt; string(22) \"/private/tmp/phpgRXd58\" [\"error\"] =&gt; int(0) [\"size\"] =&gt; int(14908679) } } Using nested array notation for uploads It is suggested that you always use the Laminas\\Http\\PhpEnvironment\\Request object to retrieve and merge the $_FILES information with the form, instead of using $_FILES directly, due to how the file information is mapped in the $_FILES array: // A $_FILES array with single input and multiple files: array(1) { [\"image-file\"]=array(2) { [\"name\"]=array(2) { [0]=string(9)\"file0.txt\" [1]=string(9)\"file1.txt\" } [\"type\"]=array(2) { [0]=string(10)\"text/plain\" [1]=string(10)\"text/html\" } } } // How Laminas\\Http\\PhpEnvironment\\Request remaps the $_FILES array: array(1) { [\"image-file\"]=array(2) { [0]=array(2) { [\"name\"]=string(9)\"file0.txt\" [\"type\"]=string(10)\"text/plain\" }, [1]=array(2) { [\"name\"]=string(9)\"file1.txt\" [\"type\"]=string(10)\"text/html\" } } } Laminas\\InputFilter\\FileInput expects the file data be in this re-mapped array format. Note: PSR-7 also remaps the $_FILES array in this way. Mezzio Request Handler If you are using a PSR-15 request handler with PSR-7 request payload, the final step involves merging $request-&gt;getParsedBody() with $request-&gt;getUploadedFiles() . public function handle(ServerRequestInterface $request) : ResponseInterface { $form = new UploadForm('upload-form'); if ($request-&gt;getMethod() === 'POST') { $post = array_merge_recursive( $request-&gt;getParsedBody(), $request-&gt;getUploadedFiles() ); $form-&gt;setData($post); if ($form-&gt;isValid()) { $data = $form-&gt;getData(); // Form is valid, save the form! return new RedirectResponse('upload-form/success'); } } return new HtmlResponse( $this-&gt;template-&gt;render('app::page-template', [ 'form' =&gt; $form, ]); ); } Upon a successful file upload, $form-&gt;getData() would return array including the file field name as a key, and a new instance of UploadedFileInterface as its value. Further operations on the uploaded file After running isValid() on the form instance, you should no longer trust the UploadedFileInterface instance stored in the PSR-7 $request to perform further operations on the uploaded file. The file may be moved by one of the filters attached to form input, but since the request is immutable, the change will not be reflected in it. Therefore, after validation, always use the file information retrieved from $form-&gt;getData() , not from $request-&gt;getUploadedFiles() . File Post-Redirect-Get Plugin When using other standard form inputs (i.e. text , checkbox , select , etc.) along with file inputs in a form, you can encounter a situation where some inputs may become invalid and the user must re-select the file and re-upload. PHP will delete uploaded files from the temporary directory at the end of the request if it has not been moved away or renamed. Re-uploading a valid file each time another form input is invalid is inefficient and annoying to users. One strategy to get around this is to split the form into multiple forms. One form for the file upload inputs and another for the other standard inputs. When you cannot separate the forms, the File Post-Redirect-Get Plugin can be used to manage the file inputs and save off valid uploads until the entire form is valid. Changing our earlier example to use the fileprg() plugin will require two changes. RenameUpload filter First, we need to add a RenameUpload filter to our form's file input, with details on where the valid files should be stored: use Laminas\\InputFilter; use Laminas\\Form\\Element; use Laminas\\Form\\Form; class UploadForm extends Form { public function __construct($name = null, $options = []) { parent::__construct($name, $options); $this-&gt;addElements(); $this-&gt;addInputFilter(); } public function addElements() { // File Input $file = new Element\\File('image-file'); $file-&gt;setLabel('Avatar Image Upload') $file-&gt;setAttribute('id', 'image-file'); $this-&gt;add($file); } public function addInputFilter() { $inputFilter = new InputFilter\\InputFilter(); // File Input $fileInput = new InputFilter\\FileInput('image-file'); $fileInput-&gt;setRequired(true); $fileInput-&gt;getFilterChain()-&gt;attachByName( 'filerenameupload', [ 'target' =&gt; './data/tmpuploads/avatar.png', 'randomize' =&gt; true, ] ); $inputFilter-&gt;add($fileInput); $this-&gt;setInputFilter($inputFilter); } } The filerenameupload options above would cause an uploaded file to be renamed and moved to: ./data/tmpuploads/avatar_4b3403665fea6.png . See the RenameUpload filter documentation for more information on its supported options. Further operations on the uploaded file If the file is coming in as a PSR-7 payload, the move operation will be performed on the passed UploadedFileInterface instance. Therefore, it will contain an expired stream and outdated target file name. After running this filter, do not use the request object to get further details about the uploaded file; use the new instance of UploadedFileInterface returned from the filter invocation. Call the fileprg plugin Next, we need to update our controller action to use the fileprg plugin: public function uploadFormAction() { $form = new UploadForm('upload-form'); $tempFile = null; $prg = $this-&gt;fileprg($form); if ($prg instanceof \\Laminas\\Http\\PhpEnvironment\\Response) { return $prg; // Return PRG redirect response } if (is_array($prg)) { if ($form-&gt;isValid()) { $data = $form-&gt;getData(); // Form is valid, save the form! return $this-&gt;redirect()-&gt;toRoute('upload-form/success'); } // Form not valid, but file uploads might be valid... // Get the temporary file information to show the user in the view $fileErrors = $form-&gt;get('image-file')-&gt;getMessages(); if (empty($fileErrors)) { $tempFile = $form-&gt;get('image-file')-&gt;getValue(); } } return [ 'form' =&gt; $form, 'tempFile' =&gt; $tempFile, ]; } Behind the scenes, the FilePRG plugin will: Run the Form's filters, namely the RenameUpload filter, to move the files out of temporary storage. Store the valid POST data in the session across requests. Change the required flag of any file inputs that had valid uploads to false . This is so that form re-submissions without uploads will not cause validation errors. User notifications In the case of a partially valid form, it is up to the developer whether to notify the user that files have been uploaded or not. For example, you may wish to hide the form input and/or display the file information. These things would be implementation details in the view or in a custom view helper. Just note that neither the FilePRG plugin nor the formFile view helper will do any automatic notifications or view changes when files have been successfully uploaded. HTML5 Multi-File Uploads With HTML5, we are able to select multiple files from a single file input using the multiple attribute. Not all browsers support multiple file uploads , but the file input will safely remain a single file upload for those browsers that do not support the feature. To enable multiple file uploads in laminas-form, set the file element's multiple attribute to true: use Laminas\\InputFilter; use Laminas\\Form\\Element; use Laminas\\Form\\Form; class UploadForm extends Form { public function __construct($name = null, $options = []) { parent::__construct($name, $options); $this-&gt;addElements(); $this-&gt;addInputFilter(); } public function addElements() { // File Input $file = new Element\\File('image-file'); $file-&gt;setLabel('Avatar Image Upload'); $file-&gt;setAttribute('id', 'image-file'); $file-&gt;setAttribute('multiple', true); // Marking as multiple $this-&gt;add($file); } public function addInputFilter() { $inputFilter = new InputFilter\\InputFilter(); // File Input $fileInput = new InputFilter\\FileInput('image-file'); $fileInput-&gt;setRequired(true); // Define validators and filters as if only one file was being uploaded. // All files will be run through the same validators and filters // automatically. $fileInput-&gt;getValidatorChain() -&gt;attachByName('filesize', ['max' =&gt; 204800]) -&gt;attachByName('filemimetype', ['mimeType' =&gt; 'image/png,image/x-png']) -&gt;attachByName('fileimagesize', ['maxWidth' =&gt; 100, 'maxHeight' =&gt; 100]); // All files will be renamed, e.g.: // ./data/tmpuploads/avatar_4b3403665fea6.png, // ./data/tmpuploads/avatar_5c45147660fb7.png $fileInput-&gt;getFilterChain()-&gt;attachByName( 'filerenameupload', [ 'target' =&gt; './data/tmpuploads/avatar.png', 'randomize' =&gt; true, ] ); $inputFilter-&gt;add($fileInput); $this-&gt;setInputFilter($inputFilter); } } You do not need to do anything special with the validators and filters to support multiple file uploads. All of the files that are uploaded will have the same validators and filters run against them automatically (from logic within FileInput ). Define them as if a single file was being uploaded. Upload Progress While pure client-based upload progress meters are starting to become available with HTML5's Progress Events , not all browsers have XMLHttpRequest level 2 support . For upload progress to work in a greater number of browsers (IE9 and below), you must use a server-side progress solution. Laminas\\ProgressBar\\Upload provides handlers that can give you the actual state of a file upload in progress. To use this feature, you need to choose one of the Upload Progress Handlers (APC, uploadprogress, or Session) and ensure that your server setup has the appropriate extension or feature enabled. Verify your php.ini session.upload settings before you begin: file_uploads = On post_max_size = 50M upload_max_filesize = 50M session.upload_progress.enabled = On session.upload_progress.freq = \"1%\" session.upload_progress.min_freq = \"1\" ; Also make certain 'upload_tmp_dir' is writable When uploading a file with a form POST, you must also include the progress identifier in a hidden input. The file upload progress view helpers provides a convenient way to add the hidden input based on your handler type. &lt;!-- File: upload-form.phtml --&gt; &lt;?php $fileElement = $form-&gt;get('image-file'); $form-&gt;prepare(); echo $this-&gt;form()-&gt;openTag($form); echo $this-&gt;formFileSessionProgress(); // Must come before the file input! ?&gt; &lt;div class=\"form-element\"&gt; &lt;?= $this-&gt;formLabel($fileElement) ?&gt; &lt;?= $this-&gt;formFile($fileElement) ?&gt; &lt;?= $this-&gt;formElementErrors($fileElement) ?&gt; &lt;/div&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;?= $this-&gt;form()-&gt;closeTag() ?&gt; When rendered, the HTML should look similar to: &lt;form name=\"upload-form\" id=\"upload-form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\"&gt; &lt;div class=\"form-element\"&gt; &lt;label for=\"image-file\"&gt;Avatar Image Upload&lt;/label&gt; &lt;input type=\"file\" name=\"image-file\" id=\"image-file\"&gt; &lt;/div&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/form&gt; There are a few different methods for getting progress information to the browser (long vs. short polling). Here we will use short polling since it is simpler and less taxing on server resources, though keep in mind it is not as responsive as long polling. When our form is submitted via AJAX, the browser will continuously poll the server for upload progress. The following is an example controller action which provides the progress information: public function uploadProgressAction() { $id = $this-&gt;params()-&gt;fromQuery('id', null); $progress = new \\Laminas\\ProgressBar\\Upload\\SessionProgress(); return new \\Laminas\\View\\Model\\JsonModel($progress-&gt;getProgress($id)); } // Returns JSON //{ // \"total\" : 204800, // \"current\" : 10240, // \"rate\" : 1024, // \"message\" : \"10kB / 200kB\", // \"done\" : false //} Performance overhead This is not the most efficient way of providing upload progress, since each polling request must go through the Laminas bootstrap process. A better example would be to use a standalone php file in the public folder that bypasses the MVC bootstrapping and only uses the essential Laminas\\ProgressBar adapters. Back in our view template, we will add Javascript to perform the AJAX POST of the form data, and to start a timeout interval for the progress polling. To keep the example code relatively short, we are using the jQuery Form plugin to do the AJAX form POST. If your project uses a different JavaScript framework (or none at all), this will hopefully at least illustrate the necessary high-level logic that would need to be performed. &lt;?php // File: upload-form.phtml // ...after the form... ?&gt; &lt;!-- Twitter Bootstrap progress bar styles: http://twitter.github.com/bootstrap/components.html#progress --&gt; &lt;div id=\"progress\" class=\"help-block\"&gt; &lt;div class=\"progress progress-info progress-striped\"&gt; &lt;div class=\"bar\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/js/jquery.form.js\"&gt;&lt;/script&gt; &lt;script&gt; var progressInterval; function getProgress() { // Poll our controller action with the progress id var url = '/upload-form/upload-progress?id=' + $('#progress_key').val(); $.getJSON(url, function(data) { if (data.status &amp;&amp; !data.status.done) { var value = Math.floor((data.status.current / data.status.total) * 100); showProgress(value, 'Uploading...'); } else { showProgress(100, 'Complete!'); clearInterval(progressInterval); } }); } function startProgress() { showProgress(0, 'Starting upload...'); progressInterval = setInterval(getProgress, 900); } function showProgress(amount, message) { $('#progress').show(); $('#progress .bar').width(amount + '%'); $('#progress &gt; p').html(message); if (amount &lt; 100) { $('#progress .progress') .addClass('progress-info active') .removeClass('progress-success'); } else { $('#progress .progress') .removeClass('progress-info active') .addClass('progress-success'); } } $(function() { // Register a 'submit' event listener on the form to perform the AJAX POST $('#upload-form').on('submit', function(e) { e.preventDefault(); if ($('#image-file').val() == '') { // No files selected, abort return; } // Perform the submit //$.fn.ajaxSubmit.debug = true; $(this).ajaxSubmit({ beforeSubmit: function(arr, $form, options) { // Notify backend that submit is via ajax arr.push({ name: \"isAjax\", value: \"1\" }); }, success: function (response, statusText, xhr, $form) { clearInterval(progressInterval); showProgress(100, 'Complete!'); // TODO: You'll need to do some custom logic here to handle a successful // form post, and when the form is invalid with validation errors. if (response.status) { // TODO: Do something with a successful form post, like redirect // window.location.replace(response.redirect); } else { // Clear the file input, otherwise the same file gets re-uploaded // http://stackoverflow.com/a/1043969 var fileInput = $('#image-file'); fileInput.replaceWith( fileInput.val('').clone( true ) ); // TODO: Do something with these errors // showErrors(response.formErrors); } }, error: function(a, b, c) { // NOTE: This callback is *not* called when the form is invalid. // It is called when the browser is unable to initiate or complete the ajax submit. // You will need to handle validation errors in the 'success' callback. console.log(a, b, c); } }); // Start the progress polling startProgress(); }); }); &lt;/script&gt; And finally, our controller action can be modified to return form status and validation messages in JSON format if we see the 'isAjax' post parameter (which was set in the JavaScript just before submit): public function uploadFormAction() { $form = new UploadForm('upload-form'); $request = $this-&gt;getRequest(); if (! $request-&gt;isPost()) { return ['form' =&gt; $form]; } // Make certain to merge the files info! $post = array_merge_recursive( $request-&gt;getPost()-&gt;toArray(), $request-&gt;getFiles()-&gt;toArray() ); $form-&gt;setData($post); if ($form-&gt;isValid()) { $data = $form-&gt;getData(); // Form is valid, save the form! if (! empty($post['isAjax'])) { return new JsonModel(array( 'status' =&gt; true, 'redirect' =&gt; $this-&gt;url()-&gt;fromRoute('upload-form/success'), 'formData' =&gt; $data, )); } // Fallback for non-JS clients return $this-&gt;redirect()-&gt;toRoute('upload-form/success'); } if (! empty($post['isAjax'])) { // Send back failure information via JSON return new JsonModel([ 'status' =&gt; false, 'formErrors' =&gt; $form-&gt;getMessages(), 'formData' =&gt; $form-&gt;getData(), ]); } return array('form' =&gt; $form); } Additional Info Related documentation: Form File Element Form File View Helper List of File Validators List of File Filters File Post-Redirect-Get Controller Plugin Laminas\\InputFilter\\FileInput Upload Progress Handlers Upload Progress View Helpers External resources and blog posts from the community: LaminasFileUploadExamples : A Laminas module with several file upload examples.","title":"File Uploads"},{"location":"file-upload/#file-uploads","text":"laminas-form provides support for file uploading by using features from each of laminas-inputfilter , laminas-validator , laminas-filter , and laminas-progressbar . These reusable framework components provide a convenient and secure way for handling file uploads in your projects.","title":"File Uploads"},{"location":"file-upload/#basic-example","text":"Handling file uploads is essentially the same as how you would use Laminas\\Form for form processing, but with some slight caveats that will be described below. In this example we will: Define a Form for backend validation and filtering. Create a view template with a &lt;form&gt; containing a file input. Process the form within a Controller action (laminas-mvc) or in a Request Handler (Mezzio).","title":"Basic Example"},{"location":"file-upload/#file-post-redirect-get-plugin","text":"When using other standard form inputs (i.e. text , checkbox , select , etc.) along with file inputs in a form, you can encounter a situation where some inputs may become invalid and the user must re-select the file and re-upload. PHP will delete uploaded files from the temporary directory at the end of the request if it has not been moved away or renamed. Re-uploading a valid file each time another form input is invalid is inefficient and annoying to users. One strategy to get around this is to split the form into multiple forms. One form for the file upload inputs and another for the other standard inputs. When you cannot separate the forms, the File Post-Redirect-Get Plugin can be used to manage the file inputs and save off valid uploads until the entire form is valid. Changing our earlier example to use the fileprg() plugin will require two changes.","title":"File Post-Redirect-Get Plugin"},{"location":"file-upload/#html5-multi-file-uploads","text":"With HTML5, we are able to select multiple files from a single file input using the multiple attribute. Not all browsers support multiple file uploads , but the file input will safely remain a single file upload for those browsers that do not support the feature. To enable multiple file uploads in laminas-form, set the file element's multiple attribute to true: use Laminas\\InputFilter; use Laminas\\Form\\Element; use Laminas\\Form\\Form; class UploadForm extends Form { public function __construct($name = null, $options = []) { parent::__construct($name, $options); $this-&gt;addElements(); $this-&gt;addInputFilter(); } public function addElements() { // File Input $file = new Element\\File('image-file'); $file-&gt;setLabel('Avatar Image Upload'); $file-&gt;setAttribute('id', 'image-file'); $file-&gt;setAttribute('multiple', true); // Marking as multiple $this-&gt;add($file); } public function addInputFilter() { $inputFilter = new InputFilter\\InputFilter(); // File Input $fileInput = new InputFilter\\FileInput('image-file'); $fileInput-&gt;setRequired(true); // Define validators and filters as if only one file was being uploaded. // All files will be run through the same validators and filters // automatically. $fileInput-&gt;getValidatorChain() -&gt;attachByName('filesize', ['max' =&gt; 204800]) -&gt;attachByName('filemimetype', ['mimeType' =&gt; 'image/png,image/x-png']) -&gt;attachByName('fileimagesize', ['maxWidth' =&gt; 100, 'maxHeight' =&gt; 100]); // All files will be renamed, e.g.: // ./data/tmpuploads/avatar_4b3403665fea6.png, // ./data/tmpuploads/avatar_5c45147660fb7.png $fileInput-&gt;getFilterChain()-&gt;attachByName( 'filerenameupload', [ 'target' =&gt; './data/tmpuploads/avatar.png', 'randomize' =&gt; true, ] ); $inputFilter-&gt;add($fileInput); $this-&gt;setInputFilter($inputFilter); } } You do not need to do anything special with the validators and filters to support multiple file uploads. All of the files that are uploaded will have the same validators and filters run against them automatically (from logic within FileInput ). Define them as if a single file was being uploaded.","title":"HTML5 Multi-File Uploads"},{"location":"file-upload/#upload-progress","text":"While pure client-based upload progress meters are starting to become available with HTML5's Progress Events , not all browsers have XMLHttpRequest level 2 support . For upload progress to work in a greater number of browsers (IE9 and below), you must use a server-side progress solution. Laminas\\ProgressBar\\Upload provides handlers that can give you the actual state of a file upload in progress. To use this feature, you need to choose one of the Upload Progress Handlers (APC, uploadprogress, or Session) and ensure that your server setup has the appropriate extension or feature enabled. Verify your php.ini session.upload settings before you begin: file_uploads = On post_max_size = 50M upload_max_filesize = 50M session.upload_progress.enabled = On session.upload_progress.freq = \"1%\" session.upload_progress.min_freq = \"1\" ; Also make certain 'upload_tmp_dir' is writable When uploading a file with a form POST, you must also include the progress identifier in a hidden input. The file upload progress view helpers provides a convenient way to add the hidden input based on your handler type. &lt;!-- File: upload-form.phtml --&gt; &lt;?php $fileElement = $form-&gt;get('image-file'); $form-&gt;prepare(); echo $this-&gt;form()-&gt;openTag($form); echo $this-&gt;formFileSessionProgress(); // Must come before the file input! ?&gt; &lt;div class=\"form-element\"&gt; &lt;?= $this-&gt;formLabel($fileElement) ?&gt; &lt;?= $this-&gt;formFile($fileElement) ?&gt; &lt;?= $this-&gt;formElementErrors($fileElement) ?&gt; &lt;/div&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;?= $this-&gt;form()-&gt;closeTag() ?&gt; When rendered, the HTML should look similar to: &lt;form name=\"upload-form\" id=\"upload-form\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\"&gt; &lt;div class=\"form-element\"&gt; &lt;label for=\"image-file\"&gt;Avatar Image Upload&lt;/label&gt; &lt;input type=\"file\" name=\"image-file\" id=\"image-file\"&gt; &lt;/div&gt; &lt;button&gt;Submit&lt;/button&gt; &lt;/form&gt; There are a few different methods for getting progress information to the browser (long vs. short polling). Here we will use short polling since it is simpler and less taxing on server resources, though keep in mind it is not as responsive as long polling. When our form is submitted via AJAX, the browser will continuously poll the server for upload progress. The following is an example controller action which provides the progress information: public function uploadProgressAction() { $id = $this-&gt;params()-&gt;fromQuery('id', null); $progress = new \\Laminas\\ProgressBar\\Upload\\SessionProgress(); return new \\Laminas\\View\\Model\\JsonModel($progress-&gt;getProgress($id)); } // Returns JSON //{ // \"total\" : 204800, // \"current\" : 10240, // \"rate\" : 1024, // \"message\" : \"10kB / 200kB\", // \"done\" : false //}","title":"Upload Progress"},{"location":"file-upload/#additional-info","text":"Related documentation: Form File Element Form File View Helper List of File Validators List of File Filters File Post-Redirect-Get Controller Plugin Laminas\\InputFilter\\FileInput Upload Progress Handlers Upload Progress View Helpers External resources and blog posts from the community: LaminasFileUploadExamples : A Laminas module with several file upload examples.","title":"Additional Info"},{"location":"intro/","text":"Introduction laminas-form is a bridge between your domain models and the view layer. It composes a thin layer of objects representing form elements, an InputFilter , and a small number of methods for binding data to and from the form and attached objects. The component consists of the following objects: Elements, which consist of a name and attributes. Fieldsets, which extend from elements, but allow composing other fieldsets and elements. Forms, which extend from Fieldsets (and thus Elements). They provide data and object binding, and compose InputFilters . Data binding is done via laminas-hydrator . To facilitate usage with the view layer, laminas-form also aggregates a number of form-specific view helpers. These accept elements, fieldsets, and/or forms, and use the attributes they compose to render markup. A small number of specialized elements are provided for accomplishing application-centric tasks. These include the Csrf element, used to prevent Cross Site Request Forgery attacks, and the Captcha element, used to display and validate CAPTCHAs . A Factory is provided to facilitate creation of elements, fieldsets, forms, and the related input filter. The default Form implementation is backed by a factory to facilitate extension and ease the process of form creation. The code related to forms can often spread between a variety of concerns: a form definition, an input filter definition, a domain model class, and one or more hydrator implementations. As such, finding the various bits of code and how they relate can become tedious. To simplify the situation, you can also annotate your domain model class, detailing the various input filter definitions, attributes, and hydrators that should all be used together. Laminas\\Form\\Annotation\\AnnotationBuilder can then be used to build the various objects you need.","title":"Introduction"},{"location":"intro/#introduction","text":"laminas-form is a bridge between your domain models and the view layer. It composes a thin layer of objects representing form elements, an InputFilter , and a small number of methods for binding data to and from the form and attached objects. The component consists of the following objects: Elements, which consist of a name and attributes. Fieldsets, which extend from elements, but allow composing other fieldsets and elements. Forms, which extend from Fieldsets (and thus Elements). They provide data and object binding, and compose InputFilters . Data binding is done via laminas-hydrator . To facilitate usage with the view layer, laminas-form also aggregates a number of form-specific view helpers. These accept elements, fieldsets, and/or forms, and use the attributes they compose to render markup. A small number of specialized elements are provided for accomplishing application-centric tasks. These include the Csrf element, used to prevent Cross Site Request Forgery attacks, and the Captcha element, used to display and validate CAPTCHAs . A Factory is provided to facilitate creation of elements, fieldsets, forms, and the related input filter. The default Form implementation is backed by a factory to facilitate extension and ease the process of form creation. The code related to forms can often spread between a variety of concerns: a form definition, an input filter definition, a domain model class, and one or more hydrator implementations. As such, finding the various bits of code and how they relate can become tedious. To simplify the situation, you can also annotate your domain model class, detailing the various input filter definitions, attributes, and hydrators that should all be used together. Laminas\\Form\\Annotation\\AnnotationBuilder can then be used to build the various objects you need.","title":"Introduction"},{"location":"quick-start/","text":"Quick Start Forms are composed of elements and fieldsets. At the bare minimum, each element or fieldset requires a name; in most situations, you'll also provide some attributes to hint to the view layer how it might render the item. The form itself generally composes an InputFilter — which you can also create directly in the form via a factory. Individual elements can hint as to what defaults to use when generating a related input for the input filter. Perform form validation by providing an array of data to the setData() method, and calling the isValid() method. If you want to simplify your work even more, you can bind an object to the form; on successful validation, it will be populated from the validated values. Programmatic Form Creation The following example demonstrates element, fieldset, and form creation, and how they are wired together. use Laminas\\Captcha; use Laminas\\Form\\Element; use Laminas\\Form\\Fieldset; use Laminas\\Form\\Form; use Laminas\\InputFilter\\Input; use Laminas\\InputFilter\\InputFilter; // Create a text element to capture the user name: $name = new Element('name'); $name-&gt;setLabel('Your name'); $name-&gt;setAttributes([ 'type' =&gt; 'text', ]); // Create a text element to capture the user email address: $email = new Element\\Email('email'); $email-&gt;setLabel('Your email address'); // Create a text element to capture the message subject: $subject = new Element('subject'); $subject-&gt;setLabel('Subject'); $subject-&gt;setAttributes([ 'type' =&gt; 'text', ]); // Create a textarea element to capture a message: $message = new Element\\Textarea('message'); $message-&gt;setLabel('Message'); // Create a CAPTCHA: $captcha = new Element\\Captcha('captcha'); $captcha-&gt;setCaptcha(new Captcha\\Dumb()); $captcha-&gt;setLabel('Please verify you are human'); // Create a CSRF token: $csrf = new Element\\Csrf('security'); // Create a submit button: $send = new Element('send'); $send-&gt;setValue('Submit'); $send-&gt;setAttributes([ 'type' =&gt; 'submit', ]); // Create the form and add all elements: $form = new Form('contact'); $form-&gt;add($name); $form-&gt;add($email); $form-&gt;add($subject); $form-&gt;add($message); $form-&gt;add($captcha); $form-&gt;add($csrf); $form-&gt;add($send); // Create an input for the \"name\" element: $nameInput = new Input('name'); /* ... configure the input, and create and configure all others ... */ // Create the input filter: $inputFilter = new InputFilter(); // Attach inputs: $inputFilter-&gt;add($nameInput); /* ... */ // Attach the input filter to the form: $form-&gt;setInputFilter($inputFilter); As a demonstration of fieldsets, let's alter the above slightly. We'll create two fieldsets, one for the sender information, and another for the message details. // Create the fieldset for sender details: $sender = new Fieldset('sender'); $sender-&gt;add($name); $sender-&gt;add($email); // Create the fieldset for message details: $details = new Fieldset('details'); $details-&gt;add($subject); $details-&gt;add($message); $form = new Form('contact'); $form-&gt;add($sender); $form-&gt;add($details); $form-&gt;add($captcha); $form-&gt;add($csrf); $form-&gt;add($send); This manual approach gives maximum flexibility over form creation; however, it comes at the expense of verbosity. In the next section, we'll look at another approach. Creation via Factory You can create the entire form and input filter at once using the Factory . This is particularly nice if you want to store your forms as pure configuration; you can then pass the configuration to the factory and be done. use Laminas\\Form\\Element; use Laminas\\Form\\Factory; use Laminas\\Hydrator\\ArraySerializable; $factory = new Factory(); $form = $factory-&gt;createForm([ 'hydrator' =&gt; ArraySerializable::class, 'elements' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Your name', ], 'type' =&gt; 'Text', ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Your email address', ] ], ], [ 'spec' =&gt; [ 'name' =&gt; 'subject', 'options' =&gt; [ 'label' =&gt; 'Subject', ], 'type' =&gt; 'Text', ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Textarea::class, 'name' =&gt; 'message', 'options' =&gt; [ 'label' =&gt; 'Message', ] ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Captcha::class, 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human.', 'captcha' =&gt; [ 'class' =&gt; 'Dumb', ], ], ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'security', ], ], [ 'spec' =&gt; [ 'name' =&gt; 'send', 'type' =&gt; 'Submit', 'attributes' =&gt; [ 'value' =&gt; 'Submit', ], ], ], ], /* If we had fieldsets, they'd go here; fieldsets contain * \"elements\" and \"fieldsets\" keys, and potentially a \"type\" * key indicating the specific FieldsetInterface * implementation to use. 'fieldsets' =&gt; [ ], */ // Configuration to pass on to // Laminas\\InputFilter\\Factory::createInputFilter() 'input_filter' =&gt; [ /* ... */ ], ]); If we wanted to use fieldsets, as we demonstrated in the previous example, we could do the following: use Laminas\\Form\\Element; use Laminas\\Form\\Factory; use Laminas\\Hydrator\\ArraySerializable; $factory = new Factory(); $form = $factory-&gt;createForm([ 'hydrator' =&gt; ArraySerializable::class, // Top-level fieldsets to define: 'fieldsets' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'sender', 'elements' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Your name', ], 'type' =&gt; 'Text' ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Your email address', ], ], ], ], ], ], [ 'spec' =&gt; [ 'name' =&gt; 'details', 'elements' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'subject', 'options' =&gt; [ 'label' =&gt; 'Subject', ], 'type' =&gt; 'Text', ], ], [ 'spec' =&gt; [ 'name' =&gt; 'message', 'type' =&gt; Element\\Textarea::class, 'options' =&gt; [ 'label' =&gt; 'Message', ], ], ], ], ], ], ], // You can specify an \"elements\" key explicitly: 'elements' =&gt; [ [ 'spec' =&gt; [ 'type' =&gt; Element\\Captcha::class, 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human.', 'captcha' =&gt; [ 'class' =&gt; 'Dumb', ], ], ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'security', ], ], // But entries without string keys are also considered elements: [ 'spec' =&gt; [ 'name' =&gt; 'send', 'type' =&gt; 'Submit', 'attributes' =&gt; [ 'value' =&gt; 'Submit', ], ], ], // Configuration to pass on to // Laminas\\InputFilter\\Factory::createInputFilter() 'input_filter' =&gt; [ /* ... */ ], ]); Note that the chief difference is nesting; otherwise, the information is basically the same. The chief benefits to using the Factory are allowing you to store definitions in configuration, and usage of significant whitespace. Factory-backed Form Extension The default Form implementation is backed by the Factory . This allows you to extend it, and define your form internally. This has the benefit of allowing a mixture of programmatic and factory-backed creation, as well as defining a form for re-use in your application. namespace Contact; use Laminas\\Captcha\\AdapterInterface as CaptchaAdapter; use Laminas\\Form\\Element; use Laminas\\Form\\Form; class ContactForm extends Form { protected $captcha; public function __construct(CaptchaAdapter $captcha) { parent::__construct(); $this-&gt;captcha = $captcha; // add() can take an Element/Fieldset instance, or a specification, from // which the appropriate object will be built. $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Your name', ], 'type' =&gt; 'Text', ]); $this-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Your email address', ], ]); $this-&gt;add([ 'name' =&gt; 'subject', 'options' =&gt; [ 'label' =&gt; 'Subject', ], 'type' =&gt; 'Text', ]); $this-&gt;add([ 'type' =&gt; Element\\Textarea::class, 'name' =&gt; 'message', 'options' =&gt; [ 'label' =&gt; 'Message', ], ]); $this-&gt;add([ 'type' =&gt; Element\\Captcha::class, 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human.', 'captcha' =&gt; $this-&gt;captcha, ], ]); $this-&gt;add(new Element\\Csrf('security')); $this-&gt;add([ 'name' =&gt; 'send', 'type' =&gt; 'Submit', 'attributes' =&gt; [ 'value' =&gt; 'Submit', ], ]); // We could also define the input filter here, or // lazy-create it in the getInputFilter() method. } } In the above example, elements are added in the constructor. This is done to allow altering and/or configuring either the form or input filter factory instances, which could then have bearing on how elements, inputs, etc. are created. In this case, it also allows injection of the CAPTCHA adapter, allowing us to configure it elsewhere in our application and inject it into the form. Validating Forms Validating forms requires three steps. First, the form must have an input filter attached. Second, you must inject the data to validate into the form. Third, you validate the form. If invalid, you can retrieve the error messages, if any. // assuming $captcha is an instance of some Laminas\\Captcha\\AdapterInterface: $form = new Contact\\ContactForm($captcha); // If the form doesn't define an input filter by default, inject one. $form-&gt;setInputFilter(new Contact\\ContactFilter()); // Get the data. In an MVC application, you might try: $data = $request-&gt;getPost(); // for POST data $data = $request-&gt;getQuery(); // for GET (or query string) data $form-&gt;setData($data); // Validate the form if ($form-&gt;isValid()) { $validatedData = $form-&gt;getData(); } else { $messages = $form-&gt;getMessages(); } Always populate select elements with options Always ensure that options for a select element are populated prior to validation; otherwise, the element will fail validation, and you will receive a NotInArray error message. If you are populating the options from a database or other data source, make sure this is done prior to validation. Alternately, you may disable the InArray validator programmatically prior to validation: $element-&gt;setDisableInArrayValidator(true); You can get the raw data if you want, by accessing the composed input filter. $filter = $form-&gt;getInputFilter(); $rawValues = $filter-&gt;getRawValues(); $nameRawValue = $filter-&gt;getRawValue('name'); Hinting to the Input Filter Often, you'll create elements that you expect to behave in the same way on each usage, and for which you'll want specific filters or validation as well. Since the input filter is a separate object, how can you achieve these latter points? Because the default form implementation composes a factory, and the default factory composes an input filter factory, you can have your elements and/or fieldsets hint to the input filter. If no input or input filter is provided in the input filter for that element, these hints will be retrieved and used to create them. To do so, one of the following must occur. For elements, they must implement Laminas\\InputFilter\\InputProviderInterface , which defines a getInputSpecification() method; for fieldsets (and, by extension, forms), they must implement Laminas\\InputFilter\\InputFilterProviderInterface , which defines a getInputFilterSpecification() method. In the case of an element, the getInputSpecification() method should return data to be used by the input filter factory to create an input. Every HTML5 ( email , url , color , etc.) element has a built-in element that uses this logic. For instance, here is how the Laminas\\Form\\Element\\Color element is defined: namespace Laminas\\Form\\Element; use Laminas\\Filter; use Laminas\\Form\\Element; use Laminas\\InputFilter\\InputProviderInterface; use Laminas\\Validator\\Regex as RegexValidator; use Laminas\\Validator\\ValidatorInterface; class Color extends Element implements InputProviderInterface { /** * Seed attributes * * @var array */ protected $attributes = [ 'type' =&gt; 'color', ]; /** * @var ValidatorInterface */ protected $validator; /** * Get validator * * @return ValidatorInterface */ protected function getValidator() { if (null === $this-&gt;validator) { $this-&gt;validator = new RegexValidator('/^#[0-9a-fA-F]{6}$/'); } return $this-&gt;validator; } /** * Provide default input rules for this element * * Attaches an email validator. * * @return array */ public function getInputSpecification() { return [ 'name' =&gt; $this-&gt;getName(), 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ['name' =&gt; Filter\\StringToLower::class], ], 'validators' =&gt; [ $this-&gt;getValidator(), ], ]; } } The above hints to the input filter to create and attach an input named after the element, marking it as required, giving it StringTrim and StringToLower filters, and defining a Regex validator. Note that you can either rely on the input filter to create filters and validators, or directly instantiate them. For fieldsets, you do very similarly; the difference is that getInputFilterSpecification() must return configuration for an input filter. namespace Contact\\Form; use Laminas\\Filter; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Validator; class SenderFieldset extends Fieldset implements InputFilterProviderInterface { public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ], 'validators' =&gt; [ [ 'name' =&gt; Validator\\StringLength::class, 'options' =&gt; [ 'min' =&gt; 3, 'max' =&gt; 256 ], ], ], ], 'email' =&gt; [ 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ], 'validators' =&gt; [ new Validator\\EmailAddress(), ], ], ]; } } Specifications are a great way to make forms, fieldsets, and elements re-usable trivially in your applications. In fact, the Captcha and Csrf elements define specifications in order to ensure they can work without additional user configuration! Use the most specific input type If you set custom input filter specification either in getInputSpecification() or in getInputFilterSpecification() , the Laminas\\InputFilter\\InputInterface set for that specific field is reset to the default Laminas\\InputFilter\\Input . Some form elements may need a particular input filter, like Laminas\\Form\\Element\\File : in this case it's mandatory to specify the type key in your custom specification to match the original one (e.g., for the file element, use Laminas\\InputFilter\\FileInput ). Binding an object As noted in the introduction, forms bridge the domain model and the view layer. Let's see that in action. When you bind() an object to the form, the following happens: The composed Hydrator calls extract() on the object, and uses the values returned, if any, to populate the value attributes of all elements. If a form contains a fieldset that itself contains another fieldset, the form will recursively extract the values. When isValid() is called, if setData() has not been previously set, the form uses the composed Hydrator to extract values from the object, and uses those during validation. If isValid() is successful (and the bindOnValidate flag is enabled, which is true by default), then the Hydrator will be passed the validated values to use to hydrate the bound object. (If you do not want this behavior, call setBindOnValidate(FormInterface::BIND_MANUAL) ). If the object implements Laminas\\InputFilter\\InputFilterAwareInterface , the input filter it composes will be used instead of the one composed on the form. This is easier to understand with an example. $contact = new ArrayObject; $contact['subject'] = '[Contact Form] '; $contact['message'] = 'Type your message here'; $form = new Contact\\ContactForm; $form-&gt;bind($contact); // form now has default values for // 'subject' and 'message' $data = [ 'name' =&gt; 'John Doe', 'email' =&gt; 'j.doe@example.tld', 'subject' =&gt; '[Contact Form] \\'sup?', ]; $form-&gt;setData($data); if ($form-&gt;isValid()) { // $contact now has the following structure: // [ // 'name' =&gt; 'John Doe', // 'email' =&gt; 'j.doe@example.tld', // 'subject' =&gt; '[Contact Form] \\'sup?', // 'message' =&gt; 'Type your message here', // ] // But is an ArrayObject instance! } When an object is bound to the form, calling getData() will return that object by default. If you want to return an associative array instead, you can pass the FormInterface::VALUES_AS_ARRAY flag to the method. use Laminas\\Form\\FormInterface; $data = $form-&gt;getData(FormInterface::VALUES_AS_ARRAY); Laminas ships several standard hydrators ; you can create custom hydrators by implementing Laminas\\Hydrator\\HydratorInterface , which looks like this: namespace Laminas\\Hydrator; interface HydratorInterface { /** @return array */ public function extract($object); public function hydrate(array $data, $object); } Rendering As noted previously, forms are meant to bridge the domain model and view layer. We've discussed the domain model binding, but what about the view? The form component ships a set of form-specific view helpers. These accept the various form objects, and introspect them in order to generate markup. Typically, they will inspect the attributes, but in special cases, they may look at other properties and composed objects. When preparing to render, you will generally want to call prepare() . This method ensures that certain injections are done, and ensures that elements nested in fieldsets and collections generate names in array notation (e.g., scoped[array][notation] ). The base view helpers used everywhere are Form , FormElement , FormLabel , and FormElementErrors . Let's use them to display the contact form. &lt;?php // within a view script $form = $this-&gt;form; $form-&gt;prepare(); // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); // Get the form label plugin $formLabel = $this-&gt;plugin('formLabel'); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); ?&gt; &lt;div class=\"form_element\"&gt; &lt;?php $name = $form-&gt;get('name'); echo $formLabel-&gt;openTag() . $name-&gt;getOption('label'); echo $this-&gt;formInput($name); echo $this-&gt;formElementErrors($name); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?php $subject = $form-&gt;get('subject'); echo $formLabel-&gt;openTag() . $subject-&gt;getOption('label'); echo $this-&gt;formInput($subject); echo $this-&gt;formElementErrors($subject); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?php $message = $form-&gt;get('message'); echo $formLabel-&gt;openTag() . $message-&gt;getOption('label'); echo $this-&gt;formTextarea($message); echo $this-&gt;formElementErrors($message); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?php $captcha = $form-&gt;get('captcha'); echo $formLabel-&gt;openTag() . $captcha-&gt;getOption('label'); echo $this-&gt;formCaptcha($captcha); echo $this-&gt;formElementErrors($captcha); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;?= $this-&gt;formElement($form-&gt;get('security')) ?&gt; &lt;?= $this-&gt;formElement($form-&gt;get('send')) ?&gt; &lt;?= $this-&gt;form()-&gt;closeTag() ?&gt; There are a few things to note about this. First, to prevent confusion in IDEs and editors when syntax highlighting, we use helpers to both open and close the form and label tags. Second, there's a lot of repetition happening here; we could easily create a partial view script or a composite helper to reduce boilerplate. Third, note that not all elements are created equal — the CSRF and submit elements don't need labels or error messages. Finally, note that the FormElement helper tries to do the right thing — it delegates actual markup generation to other view helpers. However, it can only guess what specific form helper to delegate to based on the list it has. If you introduce new form view helpers, you'll need to extend the FormElement helper, or create your own. Following the example above, your view files can quickly become long and repetitive to write. While we do not currently provide a single-line form view helper (as this reduces the form customization), we do provide convenience wrappers around emitting individual elements via the FormRow view helper, and collections of elements ( Laminas\\Form\\Element\\Collection , Laminas\\Form\\Fieldset , or Laminas\\Form\\Form ) via the FormCollection view helper (which, internally, iterates the collection and calls FormRow for each element, recursively following collections). The FormRow view helper automatically renders a label (if present), the element itself using the FormElement helper, as well as any errors that could arise. Here is the previous form, rewritten to take advantage of this helper: &lt;?php // within a view script $form = $this-&gt;form; $form-&gt;prepare(); // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); ?&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('name')) ?&gt; &lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('subject')) ?&gt; &lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('message')) ?&gt; &lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('captcha')) ?&gt; &lt;/div&gt; &lt;?= $this-&gt;formElement($form-&gt;get('security')) ?&gt; &lt;?= $this-&gt;formElement($form-&gt;get('send')) ?&gt; &lt;?= $this-&gt;form()-&gt;closeTag() ?&gt; Note that FormRow helper automatically prepends the label. If you want it to be rendered after the element itself, you can pass an optional parameter to the FormRow view helper : &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('name'), 'append') ?&gt; &lt;/div&gt; As noted previously, the FormCollection view helper will iterate any collection — including Laminas\\Form\\Element\\Collection , fieldsets, and forms — emitting each element discovered using FormRow . FormCollection does not render fieldset or form tags ; you will be responsible for emitting those yourself. The above examples can now be rewritten again: &lt;?php // within a view script $form = $this-&gt;form; $form-&gt;prepare(); // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); echo $this-&gt;formCollection($form); echo $this-&gt;form()-&gt;closeTag(); Finally, the Form view helper can optionally accept a Laminas\\Form\\Form instance; if provided, it will prepare the form, iterate it, and render all elements using either FormRow (for non-collection elements) or FormCollection (for collections and fieldsets): &lt;?php // within a view script $form = $this-&gt;form; // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); echo $this-&gt;form($form); One important point to note about the last two examples: while they greatly simplifies emitting the form, you also lose most customization opportunities. The above, for example, will not include the &lt;div class=\"form_element\"&gt;&lt;/div&gt; wrappers from the previous examples! As such, you will generally want to use this facility only when prototyping. Taking advantage of HTML5 input attributes HTML5 brings a lot of exciting features, one of them being simplified client form validations. laminas-form provides elements corresponding to the various HTML5 elements, specifying the client-side attributes required by them. Additionally, each implements InputProviderInterface , ensuring that your input filter will have reasonable default validation and filtering rules that mimic the client-side validations. Always validate server-side Although client validation is nice from a user experience point of view, it must be used in addition to server-side validation, as client validation can be easily bypassed. Validation Groups Sometimes you want to validate only a subset of form elements. As an example, let's say we're re-using our contact form over a web service; in this case, the Csrf , Captcha , and submit button elements are not of interest, and shouldn't be validated. laminas-form provides a proxy method to the underlying InputFilter 's setValidationGroup() method, allowing us to perform this operation. $form-&gt;setValidationGroup('name', 'email', 'subject', 'message'); $form-&gt;setData($data); if ($form-&gt;isValid()) { // Contains only the \"name\", \"email\", \"subject\", and \"message\" values $data = $form-&gt;getData(); } If you later want to reset the form to validate all elements, pass the FormInterface::VALIDATE_ALL flag to the setValidationGroup() method: use Laminas\\Form\\FormInterface; $form-&gt;setValidationGroup(FormInterface::VALIDATE_ALL); When your form contains nested fieldsets, you can use an array notation to validate only a subset of the fieldsets : $form-&gt;setValidationGroup(['profile' =&gt; [ 'firstname', 'lastname', ] ]); $form-&gt;setData($data); if ($form-&gt;isValid()) { // Contains only the \"firstname\" and \"lastname\" values from the // \"profile\" fieldset $data = $form-&gt;getData(); } Using Annotations Creating a complete form solution can often be tedious: you'll create a domain model object, an input filter for validating it, a form object for providing a representation for it, and potentially a hydrator for mapping the form elements and fieldsets to the domain model. Wouldn't it be nice to have a central place to define all of these? Annotations allow us to solve this problem. You can define the following behaviors with the shipped annotations in laminas-form: AllowEmpty : mark an input as allowing an empty value. This annotation does not require a value. Attributes : specify the form, fieldset, or element attributes. This annotation requires an associative array of values, in a JSON object format: @Attributes({\"class\":\"laminas_form\",\"type\":\"text\"}) . ComposedObject : specify another object with annotations to parse. Typically, this is used if a property references another object, which will then be added to your form as an additional fieldset. Expects a string value indicating the class for the object being composed: @ComposedObject(\"Namespace\\Model\\ComposedObject\") ; or an array to compose a collection: @ComposedObject({ \"target_object\":\"Namespace\\Model\\ComposedCollection\", \"is_collection\":\"true\", \"options\":{\"count\":2}}) ; target_object is the element to compose, is_collection flags this as a collection, and options can take an array of options to pass into the collection. ErrorMessage : specify the error message to return for an element in the case of a failed validation. Expects a string value. Exclude : mark a property to exclude from the form or fieldset. This annotation does not require a value. Filter : provide a specification for a filter to use on a given element. Expects an associative array of values, with a \"name\" key pointing to a string filter name, and an \"options\" key pointing to an associative array of filter options for the constructor: @Filter({\"name\": \"Boolean\", \"options\": {\"casting\":true}}) . This annotation may be specified multiple times. Flags : flags to pass to the fieldset or form composing an element or fieldset; these are usually used to specify the name or priority. The annotation expects an associative array: @Flags({\"priority\": 100}) . Hydrator : specify the hydrator class to use for this given form or fieldset. A string value is expected. InputFilter : specify the input filter class to use for this given form or fieldset. A string value is expected. Input : specify the input class to use for this given element. A string value is expected. Instance : specify an object class instance to bind to the form or fieldset. Name : specify the name of the current element, fieldset, or form. A string value is expected. Object : specify an object class instance to bind to the form or fieldset. (Note: this is deprecated in 2.4.0; use Instance instead.) Options : options to pass to the fieldset or form that are used to inform behavior — things that are not attributes; e.g. labels, CAPTCHA adapters, etc. The annotation expects an associative array: @Options({\"label\": \"Username:\"}) . Required : indicate whether an element is required. A boolean value is expected. By default, all elements are required, so this annotation is mainly present to allow disabling a requirement. Type : indicate the class to use for the current element, fieldset, or form. A string value is expected. Validator : provide a specification for a validator to use on a given element. Expects an associative array of values, with a \"name\" key pointing to a string validator name, and an \"options\" key pointing to an associative array of validator options for the constructor: @Validator({\"name\": \"StringLength\", \"options\": {\"min\":3, \"max\": 25}}) . This annotation may be specified multiple times. ContinueIfEmpty : indicate whether the element can be submitted when it is empty. A boolean value is expected. If @Required is set to false , this needs to be set to true to allow the field to be empty. To use annotations, include them in your class and/or property docblocks. Annotation names will be resolved according to the import statements in your class; as such, you can make them as long or as short as you want depending on what you import. doctrine/common dependency Form annotations require doctrine\\common , which contains an annotation parsing engine. Install it using composer: $ composer require doctrine/common Here's an example: use Laminas\\Form\\Annotation; /** * @Annotation\\Name(\"user\") * @Annotation\\Hydrator(\"Laminas\\Hydrator\\ObjectProperty\") */ class User { /** * @Annotation\\Exclude() */ public $id; /** * @Annotation\\Filter({\"name\":\"StringTrim\"}) * @Annotation\\Validator({\"name\":\"StringLength\", \"options\":{\"min\":1, \"max\":25}}) * @Annotation\\Validator({\"name\":\"Regex\", \"options\":{\"pattern\":\"/^[a-zA-Z][a-zA-Z0-9_-]{0,24}$/\"}}) * @Annotation\\Attributes({\"type\":\"text\"}) * @Annotation\\Options({\"label\":\"Username:\"}) */ public $username; /** * @Annotation\\Type(\"Laminas\\Form\\Element\\Email\") * @Annotation\\Options({\"label\":\"Your email address:\"}) */ public $email; } The above will hint to the annotation builder to create a form with name \"user\", which uses the hydrator Laminas\\Hydrator\\ObjectProperty . That form will have two elements, \"username\" and \"email\". The \"username\" element will have an associated input that has a StringTrim filter, and two validators: a StringLength validator indicating the username is between 1 and 25 characters, and a Regex validator asserting it follows a specific accepted pattern. The form element itself will have an attribute \"type\" with value \"text\" (a text element), and a label \"Username:\". The \"email\" element will be of type Laminas\\Form\\Element\\Email , and have the label \"Your email address:\". To use the above, we need Laminas\\Form\\Annotation\\AnnotationBuilder : use Laminas\\Form\\Annotation\\AnnotationBuilder; $builder = new AnnotationBuilder(); $form = $builder-&gt;createForm(User::class); At this point, you have a form with the appropriate hydrator attached, an input filter with the appropriate inputs, and all elements. You're not done In all likelihood, you'll need to add some more elements to the form you construct. For example, you'll want a submit button, and likely a CSRF-protection element. We recommend creating a fieldset with common elements such as these that you can then attach to the form you build via annotations.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"Forms are composed of elements and fieldsets. At the bare minimum, each element or fieldset requires a name; in most situations, you'll also provide some attributes to hint to the view layer how it might render the item. The form itself generally composes an InputFilter — which you can also create directly in the form via a factory. Individual elements can hint as to what defaults to use when generating a related input for the input filter. Perform form validation by providing an array of data to the setData() method, and calling the isValid() method. If you want to simplify your work even more, you can bind an object to the form; on successful validation, it will be populated from the validated values.","title":"Quick Start"},{"location":"quick-start/#programmatic-form-creation","text":"The following example demonstrates element, fieldset, and form creation, and how they are wired together. use Laminas\\Captcha; use Laminas\\Form\\Element; use Laminas\\Form\\Fieldset; use Laminas\\Form\\Form; use Laminas\\InputFilter\\Input; use Laminas\\InputFilter\\InputFilter; // Create a text element to capture the user name: $name = new Element('name'); $name-&gt;setLabel('Your name'); $name-&gt;setAttributes([ 'type' =&gt; 'text', ]); // Create a text element to capture the user email address: $email = new Element\\Email('email'); $email-&gt;setLabel('Your email address'); // Create a text element to capture the message subject: $subject = new Element('subject'); $subject-&gt;setLabel('Subject'); $subject-&gt;setAttributes([ 'type' =&gt; 'text', ]); // Create a textarea element to capture a message: $message = new Element\\Textarea('message'); $message-&gt;setLabel('Message'); // Create a CAPTCHA: $captcha = new Element\\Captcha('captcha'); $captcha-&gt;setCaptcha(new Captcha\\Dumb()); $captcha-&gt;setLabel('Please verify you are human'); // Create a CSRF token: $csrf = new Element\\Csrf('security'); // Create a submit button: $send = new Element('send'); $send-&gt;setValue('Submit'); $send-&gt;setAttributes([ 'type' =&gt; 'submit', ]); // Create the form and add all elements: $form = new Form('contact'); $form-&gt;add($name); $form-&gt;add($email); $form-&gt;add($subject); $form-&gt;add($message); $form-&gt;add($captcha); $form-&gt;add($csrf); $form-&gt;add($send); // Create an input for the \"name\" element: $nameInput = new Input('name'); /* ... configure the input, and create and configure all others ... */ // Create the input filter: $inputFilter = new InputFilter(); // Attach inputs: $inputFilter-&gt;add($nameInput); /* ... */ // Attach the input filter to the form: $form-&gt;setInputFilter($inputFilter); As a demonstration of fieldsets, let's alter the above slightly. We'll create two fieldsets, one for the sender information, and another for the message details. // Create the fieldset for sender details: $sender = new Fieldset('sender'); $sender-&gt;add($name); $sender-&gt;add($email); // Create the fieldset for message details: $details = new Fieldset('details'); $details-&gt;add($subject); $details-&gt;add($message); $form = new Form('contact'); $form-&gt;add($sender); $form-&gt;add($details); $form-&gt;add($captcha); $form-&gt;add($csrf); $form-&gt;add($send); This manual approach gives maximum flexibility over form creation; however, it comes at the expense of verbosity. In the next section, we'll look at another approach.","title":"Programmatic Form Creation"},{"location":"quick-start/#creation-via-factory","text":"You can create the entire form and input filter at once using the Factory . This is particularly nice if you want to store your forms as pure configuration; you can then pass the configuration to the factory and be done. use Laminas\\Form\\Element; use Laminas\\Form\\Factory; use Laminas\\Hydrator\\ArraySerializable; $factory = new Factory(); $form = $factory-&gt;createForm([ 'hydrator' =&gt; ArraySerializable::class, 'elements' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Your name', ], 'type' =&gt; 'Text', ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Your email address', ] ], ], [ 'spec' =&gt; [ 'name' =&gt; 'subject', 'options' =&gt; [ 'label' =&gt; 'Subject', ], 'type' =&gt; 'Text', ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Textarea::class, 'name' =&gt; 'message', 'options' =&gt; [ 'label' =&gt; 'Message', ] ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Captcha::class, 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human.', 'captcha' =&gt; [ 'class' =&gt; 'Dumb', ], ], ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'security', ], ], [ 'spec' =&gt; [ 'name' =&gt; 'send', 'type' =&gt; 'Submit', 'attributes' =&gt; [ 'value' =&gt; 'Submit', ], ], ], ], /* If we had fieldsets, they'd go here; fieldsets contain * \"elements\" and \"fieldsets\" keys, and potentially a \"type\" * key indicating the specific FieldsetInterface * implementation to use. 'fieldsets' =&gt; [ ], */ // Configuration to pass on to // Laminas\\InputFilter\\Factory::createInputFilter() 'input_filter' =&gt; [ /* ... */ ], ]); If we wanted to use fieldsets, as we demonstrated in the previous example, we could do the following: use Laminas\\Form\\Element; use Laminas\\Form\\Factory; use Laminas\\Hydrator\\ArraySerializable; $factory = new Factory(); $form = $factory-&gt;createForm([ 'hydrator' =&gt; ArraySerializable::class, // Top-level fieldsets to define: 'fieldsets' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'sender', 'elements' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Your name', ], 'type' =&gt; 'Text' ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Your email address', ], ], ], ], ], ], [ 'spec' =&gt; [ 'name' =&gt; 'details', 'elements' =&gt; [ [ 'spec' =&gt; [ 'name' =&gt; 'subject', 'options' =&gt; [ 'label' =&gt; 'Subject', ], 'type' =&gt; 'Text', ], ], [ 'spec' =&gt; [ 'name' =&gt; 'message', 'type' =&gt; Element\\Textarea::class, 'options' =&gt; [ 'label' =&gt; 'Message', ], ], ], ], ], ], ], // You can specify an \"elements\" key explicitly: 'elements' =&gt; [ [ 'spec' =&gt; [ 'type' =&gt; Element\\Captcha::class, 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human.', 'captcha' =&gt; [ 'class' =&gt; 'Dumb', ], ], ], ], [ 'spec' =&gt; [ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'security', ], ], // But entries without string keys are also considered elements: [ 'spec' =&gt; [ 'name' =&gt; 'send', 'type' =&gt; 'Submit', 'attributes' =&gt; [ 'value' =&gt; 'Submit', ], ], ], // Configuration to pass on to // Laminas\\InputFilter\\Factory::createInputFilter() 'input_filter' =&gt; [ /* ... */ ], ]); Note that the chief difference is nesting; otherwise, the information is basically the same. The chief benefits to using the Factory are allowing you to store definitions in configuration, and usage of significant whitespace.","title":"Creation via Factory"},{"location":"quick-start/#factory-backed-form-extension","text":"The default Form implementation is backed by the Factory . This allows you to extend it, and define your form internally. This has the benefit of allowing a mixture of programmatic and factory-backed creation, as well as defining a form for re-use in your application. namespace Contact; use Laminas\\Captcha\\AdapterInterface as CaptchaAdapter; use Laminas\\Form\\Element; use Laminas\\Form\\Form; class ContactForm extends Form { protected $captcha; public function __construct(CaptchaAdapter $captcha) { parent::__construct(); $this-&gt;captcha = $captcha; // add() can take an Element/Fieldset instance, or a specification, from // which the appropriate object will be built. $this-&gt;add([ 'name' =&gt; 'name', 'options' =&gt; [ 'label' =&gt; 'Your name', ], 'type' =&gt; 'Text', ]); $this-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Your email address', ], ]); $this-&gt;add([ 'name' =&gt; 'subject', 'options' =&gt; [ 'label' =&gt; 'Subject', ], 'type' =&gt; 'Text', ]); $this-&gt;add([ 'type' =&gt; Element\\Textarea::class, 'name' =&gt; 'message', 'options' =&gt; [ 'label' =&gt; 'Message', ], ]); $this-&gt;add([ 'type' =&gt; Element\\Captcha::class, 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human.', 'captcha' =&gt; $this-&gt;captcha, ], ]); $this-&gt;add(new Element\\Csrf('security')); $this-&gt;add([ 'name' =&gt; 'send', 'type' =&gt; 'Submit', 'attributes' =&gt; [ 'value' =&gt; 'Submit', ], ]); // We could also define the input filter here, or // lazy-create it in the getInputFilter() method. } } In the above example, elements are added in the constructor. This is done to allow altering and/or configuring either the form or input filter factory instances, which could then have bearing on how elements, inputs, etc. are created. In this case, it also allows injection of the CAPTCHA adapter, allowing us to configure it elsewhere in our application and inject it into the form.","title":"Factory-backed Form Extension"},{"location":"quick-start/#validating-forms","text":"Validating forms requires three steps. First, the form must have an input filter attached. Second, you must inject the data to validate into the form. Third, you validate the form. If invalid, you can retrieve the error messages, if any. // assuming $captcha is an instance of some Laminas\\Captcha\\AdapterInterface: $form = new Contact\\ContactForm($captcha); // If the form doesn't define an input filter by default, inject one. $form-&gt;setInputFilter(new Contact\\ContactFilter()); // Get the data. In an MVC application, you might try: $data = $request-&gt;getPost(); // for POST data $data = $request-&gt;getQuery(); // for GET (or query string) data $form-&gt;setData($data); // Validate the form if ($form-&gt;isValid()) { $validatedData = $form-&gt;getData(); } else { $messages = $form-&gt;getMessages(); }","title":"Validating Forms"},{"location":"quick-start/#hinting-to-the-input-filter","text":"Often, you'll create elements that you expect to behave in the same way on each usage, and for which you'll want specific filters or validation as well. Since the input filter is a separate object, how can you achieve these latter points? Because the default form implementation composes a factory, and the default factory composes an input filter factory, you can have your elements and/or fieldsets hint to the input filter. If no input or input filter is provided in the input filter for that element, these hints will be retrieved and used to create them. To do so, one of the following must occur. For elements, they must implement Laminas\\InputFilter\\InputProviderInterface , which defines a getInputSpecification() method; for fieldsets (and, by extension, forms), they must implement Laminas\\InputFilter\\InputFilterProviderInterface , which defines a getInputFilterSpecification() method. In the case of an element, the getInputSpecification() method should return data to be used by the input filter factory to create an input. Every HTML5 ( email , url , color , etc.) element has a built-in element that uses this logic. For instance, here is how the Laminas\\Form\\Element\\Color element is defined: namespace Laminas\\Form\\Element; use Laminas\\Filter; use Laminas\\Form\\Element; use Laminas\\InputFilter\\InputProviderInterface; use Laminas\\Validator\\Regex as RegexValidator; use Laminas\\Validator\\ValidatorInterface; class Color extends Element implements InputProviderInterface { /** * Seed attributes * * @var array */ protected $attributes = [ 'type' =&gt; 'color', ]; /** * @var ValidatorInterface */ protected $validator; /** * Get validator * * @return ValidatorInterface */ protected function getValidator() { if (null === $this-&gt;validator) { $this-&gt;validator = new RegexValidator('/^#[0-9a-fA-F]{6}$/'); } return $this-&gt;validator; } /** * Provide default input rules for this element * * Attaches an email validator. * * @return array */ public function getInputSpecification() { return [ 'name' =&gt; $this-&gt;getName(), 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ['name' =&gt; Filter\\StringToLower::class], ], 'validators' =&gt; [ $this-&gt;getValidator(), ], ]; } } The above hints to the input filter to create and attach an input named after the element, marking it as required, giving it StringTrim and StringToLower filters, and defining a Regex validator. Note that you can either rely on the input filter to create filters and validators, or directly instantiate them. For fieldsets, you do very similarly; the difference is that getInputFilterSpecification() must return configuration for an input filter. namespace Contact\\Form; use Laminas\\Filter; use Laminas\\Form\\Fieldset; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Validator; class SenderFieldset extends Fieldset implements InputFilterProviderInterface { public function getInputFilterSpecification() { return [ 'name' =&gt; [ 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ], 'validators' =&gt; [ [ 'name' =&gt; Validator\\StringLength::class, 'options' =&gt; [ 'min' =&gt; 3, 'max' =&gt; 256 ], ], ], ], 'email' =&gt; [ 'required' =&gt; true, 'filters' =&gt; [ ['name' =&gt; Filter\\StringTrim::class], ], 'validators' =&gt; [ new Validator\\EmailAddress(), ], ], ]; } } Specifications are a great way to make forms, fieldsets, and elements re-usable trivially in your applications. In fact, the Captcha and Csrf elements define specifications in order to ensure they can work without additional user configuration!","title":"Hinting to the Input Filter"},{"location":"quick-start/#binding-an-object","text":"As noted in the introduction, forms bridge the domain model and the view layer. Let's see that in action. When you bind() an object to the form, the following happens: The composed Hydrator calls extract() on the object, and uses the values returned, if any, to populate the value attributes of all elements. If a form contains a fieldset that itself contains another fieldset, the form will recursively extract the values. When isValid() is called, if setData() has not been previously set, the form uses the composed Hydrator to extract values from the object, and uses those during validation. If isValid() is successful (and the bindOnValidate flag is enabled, which is true by default), then the Hydrator will be passed the validated values to use to hydrate the bound object. (If you do not want this behavior, call setBindOnValidate(FormInterface::BIND_MANUAL) ). If the object implements Laminas\\InputFilter\\InputFilterAwareInterface , the input filter it composes will be used instead of the one composed on the form. This is easier to understand with an example. $contact = new ArrayObject; $contact['subject'] = '[Contact Form] '; $contact['message'] = 'Type your message here'; $form = new Contact\\ContactForm; $form-&gt;bind($contact); // form now has default values for // 'subject' and 'message' $data = [ 'name' =&gt; 'John Doe', 'email' =&gt; 'j.doe@example.tld', 'subject' =&gt; '[Contact Form] \\'sup?', ]; $form-&gt;setData($data); if ($form-&gt;isValid()) { // $contact now has the following structure: // [ // 'name' =&gt; 'John Doe', // 'email' =&gt; 'j.doe@example.tld', // 'subject' =&gt; '[Contact Form] \\'sup?', // 'message' =&gt; 'Type your message here', // ] // But is an ArrayObject instance! } When an object is bound to the form, calling getData() will return that object by default. If you want to return an associative array instead, you can pass the FormInterface::VALUES_AS_ARRAY flag to the method. use Laminas\\Form\\FormInterface; $data = $form-&gt;getData(FormInterface::VALUES_AS_ARRAY); Laminas ships several standard hydrators ; you can create custom hydrators by implementing Laminas\\Hydrator\\HydratorInterface , which looks like this: namespace Laminas\\Hydrator; interface HydratorInterface { /** @return array */ public function extract($object); public function hydrate(array $data, $object); }","title":"Binding an object"},{"location":"quick-start/#rendering","text":"As noted previously, forms are meant to bridge the domain model and view layer. We've discussed the domain model binding, but what about the view? The form component ships a set of form-specific view helpers. These accept the various form objects, and introspect them in order to generate markup. Typically, they will inspect the attributes, but in special cases, they may look at other properties and composed objects. When preparing to render, you will generally want to call prepare() . This method ensures that certain injections are done, and ensures that elements nested in fieldsets and collections generate names in array notation (e.g., scoped[array][notation] ). The base view helpers used everywhere are Form , FormElement , FormLabel , and FormElementErrors . Let's use them to display the contact form. &lt;?php // within a view script $form = $this-&gt;form; $form-&gt;prepare(); // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); // Get the form label plugin $formLabel = $this-&gt;plugin('formLabel'); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); ?&gt; &lt;div class=\"form_element\"&gt; &lt;?php $name = $form-&gt;get('name'); echo $formLabel-&gt;openTag() . $name-&gt;getOption('label'); echo $this-&gt;formInput($name); echo $this-&gt;formElementErrors($name); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?php $subject = $form-&gt;get('subject'); echo $formLabel-&gt;openTag() . $subject-&gt;getOption('label'); echo $this-&gt;formInput($subject); echo $this-&gt;formElementErrors($subject); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?php $message = $form-&gt;get('message'); echo $formLabel-&gt;openTag() . $message-&gt;getOption('label'); echo $this-&gt;formTextarea($message); echo $this-&gt;formElementErrors($message); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?php $captcha = $form-&gt;get('captcha'); echo $formLabel-&gt;openTag() . $captcha-&gt;getOption('label'); echo $this-&gt;formCaptcha($captcha); echo $this-&gt;formElementErrors($captcha); echo $formLabel-&gt;closeTag(); ?&gt;&lt;/div&gt; &lt;?= $this-&gt;formElement($form-&gt;get('security')) ?&gt; &lt;?= $this-&gt;formElement($form-&gt;get('send')) ?&gt; &lt;?= $this-&gt;form()-&gt;closeTag() ?&gt; There are a few things to note about this. First, to prevent confusion in IDEs and editors when syntax highlighting, we use helpers to both open and close the form and label tags. Second, there's a lot of repetition happening here; we could easily create a partial view script or a composite helper to reduce boilerplate. Third, note that not all elements are created equal — the CSRF and submit elements don't need labels or error messages. Finally, note that the FormElement helper tries to do the right thing — it delegates actual markup generation to other view helpers. However, it can only guess what specific form helper to delegate to based on the list it has. If you introduce new form view helpers, you'll need to extend the FormElement helper, or create your own. Following the example above, your view files can quickly become long and repetitive to write. While we do not currently provide a single-line form view helper (as this reduces the form customization), we do provide convenience wrappers around emitting individual elements via the FormRow view helper, and collections of elements ( Laminas\\Form\\Element\\Collection , Laminas\\Form\\Fieldset , or Laminas\\Form\\Form ) via the FormCollection view helper (which, internally, iterates the collection and calls FormRow for each element, recursively following collections). The FormRow view helper automatically renders a label (if present), the element itself using the FormElement helper, as well as any errors that could arise. Here is the previous form, rewritten to take advantage of this helper: &lt;?php // within a view script $form = $this-&gt;form; $form-&gt;prepare(); // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); ?&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('name')) ?&gt; &lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('subject')) ?&gt; &lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('message')) ?&gt; &lt;/div&gt; &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('captcha')) ?&gt; &lt;/div&gt; &lt;?= $this-&gt;formElement($form-&gt;get('security')) ?&gt; &lt;?= $this-&gt;formElement($form-&gt;get('send')) ?&gt; &lt;?= $this-&gt;form()-&gt;closeTag() ?&gt; Note that FormRow helper automatically prepends the label. If you want it to be rendered after the element itself, you can pass an optional parameter to the FormRow view helper : &lt;div class=\"form_element\"&gt; &lt;?= $this-&gt;formRow($form-&gt;get('name'), 'append') ?&gt; &lt;/div&gt; As noted previously, the FormCollection view helper will iterate any collection — including Laminas\\Form\\Element\\Collection , fieldsets, and forms — emitting each element discovered using FormRow . FormCollection does not render fieldset or form tags ; you will be responsible for emitting those yourself. The above examples can now be rewritten again: &lt;?php // within a view script $form = $this-&gt;form; $form-&gt;prepare(); // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); echo $this-&gt;formCollection($form); echo $this-&gt;form()-&gt;closeTag(); Finally, the Form view helper can optionally accept a Laminas\\Form\\Form instance; if provided, it will prepare the form, iterate it, and render all elements using either FormRow (for non-collection elements) or FormCollection (for collections and fieldsets): &lt;?php // within a view script $form = $this-&gt;form; // Assuming the \"contact/process\" route exists... $form-&gt;setAttribute('action', $this-&gt;url('contact/process')); // Set the method attribute for the form $form-&gt;setAttribute('method', 'post'); echo $this-&gt;form($form); One important point to note about the last two examples: while they greatly simplifies emitting the form, you also lose most customization opportunities. The above, for example, will not include the &lt;div class=\"form_element\"&gt;&lt;/div&gt; wrappers from the previous examples! As such, you will generally want to use this facility only when prototyping.","title":"Rendering"},{"location":"quick-start/#taking-advantage-of-html5-input-attributes","text":"HTML5 brings a lot of exciting features, one of them being simplified client form validations. laminas-form provides elements corresponding to the various HTML5 elements, specifying the client-side attributes required by them. Additionally, each implements InputProviderInterface , ensuring that your input filter will have reasonable default validation and filtering rules that mimic the client-side validations.","title":"Taking advantage of HTML5 input attributes"},{"location":"quick-start/#validation-groups","text":"Sometimes you want to validate only a subset of form elements. As an example, let's say we're re-using our contact form over a web service; in this case, the Csrf , Captcha , and submit button elements are not of interest, and shouldn't be validated. laminas-form provides a proxy method to the underlying InputFilter 's setValidationGroup() method, allowing us to perform this operation. $form-&gt;setValidationGroup('name', 'email', 'subject', 'message'); $form-&gt;setData($data); if ($form-&gt;isValid()) { // Contains only the \"name\", \"email\", \"subject\", and \"message\" values $data = $form-&gt;getData(); } If you later want to reset the form to validate all elements, pass the FormInterface::VALIDATE_ALL flag to the setValidationGroup() method: use Laminas\\Form\\FormInterface; $form-&gt;setValidationGroup(FormInterface::VALIDATE_ALL); When your form contains nested fieldsets, you can use an array notation to validate only a subset of the fieldsets : $form-&gt;setValidationGroup(['profile' =&gt; [ 'firstname', 'lastname', ] ]); $form-&gt;setData($data); if ($form-&gt;isValid()) { // Contains only the \"firstname\" and \"lastname\" values from the // \"profile\" fieldset $data = $form-&gt;getData(); }","title":"Validation Groups"},{"location":"quick-start/#using-annotations","text":"Creating a complete form solution can often be tedious: you'll create a domain model object, an input filter for validating it, a form object for providing a representation for it, and potentially a hydrator for mapping the form elements and fieldsets to the domain model. Wouldn't it be nice to have a central place to define all of these? Annotations allow us to solve this problem. You can define the following behaviors with the shipped annotations in laminas-form: AllowEmpty : mark an input as allowing an empty value. This annotation does not require a value. Attributes : specify the form, fieldset, or element attributes. This annotation requires an associative array of values, in a JSON object format: @Attributes({\"class\":\"laminas_form\",\"type\":\"text\"}) . ComposedObject : specify another object with annotations to parse. Typically, this is used if a property references another object, which will then be added to your form as an additional fieldset. Expects a string value indicating the class for the object being composed: @ComposedObject(\"Namespace\\Model\\ComposedObject\") ; or an array to compose a collection: @ComposedObject({ \"target_object\":\"Namespace\\Model\\ComposedCollection\", \"is_collection\":\"true\", \"options\":{\"count\":2}}) ; target_object is the element to compose, is_collection flags this as a collection, and options can take an array of options to pass into the collection. ErrorMessage : specify the error message to return for an element in the case of a failed validation. Expects a string value. Exclude : mark a property to exclude from the form or fieldset. This annotation does not require a value. Filter : provide a specification for a filter to use on a given element. Expects an associative array of values, with a \"name\" key pointing to a string filter name, and an \"options\" key pointing to an associative array of filter options for the constructor: @Filter({\"name\": \"Boolean\", \"options\": {\"casting\":true}}) . This annotation may be specified multiple times. Flags : flags to pass to the fieldset or form composing an element or fieldset; these are usually used to specify the name or priority. The annotation expects an associative array: @Flags({\"priority\": 100}) . Hydrator : specify the hydrator class to use for this given form or fieldset. A string value is expected. InputFilter : specify the input filter class to use for this given form or fieldset. A string value is expected. Input : specify the input class to use for this given element. A string value is expected. Instance : specify an object class instance to bind to the form or fieldset. Name : specify the name of the current element, fieldset, or form. A string value is expected. Object : specify an object class instance to bind to the form or fieldset. (Note: this is deprecated in 2.4.0; use Instance instead.) Options : options to pass to the fieldset or form that are used to inform behavior — things that are not attributes; e.g. labels, CAPTCHA adapters, etc. The annotation expects an associative array: @Options({\"label\": \"Username:\"}) . Required : indicate whether an element is required. A boolean value is expected. By default, all elements are required, so this annotation is mainly present to allow disabling a requirement. Type : indicate the class to use for the current element, fieldset, or form. A string value is expected. Validator : provide a specification for a validator to use on a given element. Expects an associative array of values, with a \"name\" key pointing to a string validator name, and an \"options\" key pointing to an associative array of validator options for the constructor: @Validator({\"name\": \"StringLength\", \"options\": {\"min\":3, \"max\": 25}}) . This annotation may be specified multiple times. ContinueIfEmpty : indicate whether the element can be submitted when it is empty. A boolean value is expected. If @Required is set to false , this needs to be set to true to allow the field to be empty. To use annotations, include them in your class and/or property docblocks. Annotation names will be resolved according to the import statements in your class; as such, you can make them as long or as short as you want depending on what you import.","title":"Using Annotations"},{"location":"application-integration/usage-in-a-laminas-mvc-application/","text":"Usage in a laminas-mvc Application The following example shows one potential use case of laminas-form within a laminas-mvc based application. The example uses a module, a controller and the laminas-form element manager. The example is based on the tutorial application which builds an album inventory system. Before starting, make sure laminas-form is installed and configured. Create Form Create a form as separate class using the init method , e.g. module/Album/src/Form/AlbumForm.php : namespace Album\\Form; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\Form\\Element\\Text; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Validator\\StringLength; class AlbumForm extends Form implements InputFilterProviderInterface { public function init() : void { // Title $this-&gt;add([ 'name' =&gt; 'title', 'type' =&gt; Text:class, 'options' =&gt; [ 'label' =&gt; 'Title', ], ]); // … } public function getInputFilterSpecification() : array { return [ // Title [ 'name' =&gt; 'title', 'filters' =&gt; [ ['name' =&gt; StripTags::class], ['name' =&gt; StringTrim::class], ], 'validators' =&gt; [ [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 1, 'max' =&gt; 100, ], ], ], ], // … ]; } } Using Form Create Controller Create a controller class and inject the form via the constructor, e.g. module/Album/Controller/AlbumController.php : namespace Album\\Controller; use Album\\Form\\AlbumForm; use Laminas\\Form\\FormInterface; use Laminas\\Mvc\\Controller\\AbstractActionController; class AlbumController extends AbstractActionController { /** @var FormInterface */ private $form; public function __construct(AlbumForm $form) { $this-&gt;form = $form; } public function addAction() { // Set action attribute $this-&gt;form-&gt;setAttribute( 'action', $this-&gt;url()-&gt;fromRoute('album', ['action' =&gt; 'add']) ); $variables = ['form' =&gt; $this-&gt;form]; if (! $this-&gt;getRequest()-&gt;isPost()) { return $variables; } // Validation $this-&gt;form-&gt;setData($this-&gt;getRequest()-&gt;getPost()); if (! $this-&gt;form-&gt;isValid()) { return $variables; } // … return $this-&gt;redirect()-&gt;toRoute('album', ['action' =&gt; 'add']); } } Create Factory for Controller Fetch the AlbumForm from the form element manager in a factory, e.g. src/Album/Controller/AlbumControllerFactory.php : namespace Album\\Controller; use Album\\Form\\AlbumForm; use Laminas\\ServiceManager\\PluginManagerInterface; use Psr\\Container\\ContainerInterface; class AlbumControllerFactory { public function __invoke(ContainerInterface $container) : AlbumController { /** @var PluginManagerInterface $formElementManager */ $formElementManager = $container-&gt;get('FormElementManager'); /** @var AlbumForm */ $form = $formElementManager-&gt;get(AlbumForm::class); return new AlbumController($form); } } Instantiating the Form The form element manager is used instead of directly instantiating the form to ensure to get the input filter manager injected. This allows usage of any input filter registered with the input filter managers which includes custom filters and validators. Custom form elements can also be used in this way. Additionally the form element manager calls the init method after instantiating the form, ensuring all dependencies are fully injected first. Register Form and Controller If no separate factory is required for the form, then the form element manager will instantiating the form class. Otherwise the form must be registered. To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Album/config/module.config.php : namespace Album; return [ 'controllers' =&gt; [ 'factories' =&gt; [ // Add this line Controller\\AlbumController::class =&gt; Controller\\AlbumControllerFactory::class, ], ], // … ]; Create View Script Create a view script in the module, e.g. module/Album/view/album/album/add.phtml : &lt;?php /** * @var Laminas\\View\\Renderer\\PhpRenderer|Laminas\\Form\\View\\HelperTrait $this * @var Laminas\\Form\\Form $form */ $this-&gt;headTitle('Add new album'); ?&gt; &lt;h1&gt;Add new album&lt;/h1&gt; &lt;?= $this-&gt;form($form) ?&gt; The Form view helper is used to render all HTML for the form.","title":"Usage in a laminas-mvc application"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#usage-in-a-laminas-mvc-application","text":"The following example shows one potential use case of laminas-form within a laminas-mvc based application. The example uses a module, a controller and the laminas-form element manager. The example is based on the tutorial application which builds an album inventory system. Before starting, make sure laminas-form is installed and configured.","title":"Usage in a laminas-mvc Application"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#create-form","text":"Create a form as separate class using the init method , e.g. module/Album/src/Form/AlbumForm.php : namespace Album\\Form; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\Form\\Element\\Text; use Laminas\\Form\\Form; use Laminas\\InputFilter\\InputFilterProviderInterface; use Laminas\\Validator\\StringLength; class AlbumForm extends Form implements InputFilterProviderInterface { public function init() : void { // Title $this-&gt;add([ 'name' =&gt; 'title', 'type' =&gt; Text:class, 'options' =&gt; [ 'label' =&gt; 'Title', ], ]); // … } public function getInputFilterSpecification() : array { return [ // Title [ 'name' =&gt; 'title', 'filters' =&gt; [ ['name' =&gt; StripTags::class], ['name' =&gt; StringTrim::class], ], 'validators' =&gt; [ [ 'name' =&gt; StringLength::class, 'options' =&gt; [ 'min' =&gt; 1, 'max' =&gt; 100, ], ], ], ], // … ]; } }","title":"Create Form"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#using-form","text":"","title":"Using Form"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#register-form-and-controller","text":"If no separate factory is required for the form, then the form element manager will instantiating the form class. Otherwise the form must be registered. To register the controller for the application, extend the configuration of the module. Add the following lines to the module configuration file, e.g. module/Album/config/module.config.php : namespace Album; return [ 'controllers' =&gt; [ 'factories' =&gt; [ // Add this line Controller\\AlbumController::class =&gt; Controller\\AlbumControllerFactory::class, ], ], // … ];","title":"Register Form and Controller"},{"location":"application-integration/usage-in-a-laminas-mvc-application/#create-view-script","text":"Create a view script in the module, e.g. module/Album/view/album/album/add.phtml : &lt;?php /** * @var Laminas\\View\\Renderer\\PhpRenderer|Laminas\\Form\\View\\HelperTrait $this * @var Laminas\\Form\\Form $form */ $this-&gt;headTitle('Add new album'); ?&gt; &lt;h1&gt;Add new album&lt;/h1&gt; &lt;?= $this-&gt;form($form) ?&gt; The Form view helper is used to render all HTML for the form.","title":"Create View Script"},{"location":"element/button/","text":"Button Laminas\\Form\\Element\\Button represents a button form input. It can be used with the Laminas\\Form\\View\\Helper\\FormButton view helper. Laminas\\Form\\Element\\Button extends from Laminas\\Form\\Element . Basic Usage This element automatically adds a type attribute of value button . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $button = new Element\\Button('my-button'); $button-&gt;setLabel('My Button'); $button-&gt;setValue('foo'); $form = new Form('my-form'); $form-&gt;add($button);","title":"button"},{"location":"element/button/#button","text":"Laminas\\Form\\Element\\Button represents a button form input. It can be used with the Laminas\\Form\\View\\Helper\\FormButton view helper. Laminas\\Form\\Element\\Button extends from Laminas\\Form\\Element .","title":"Button"},{"location":"element/button/#basic-usage","text":"This element automatically adds a type attribute of value button . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $button = new Element\\Button('my-button'); $button-&gt;setLabel('My Button'); $button-&gt;setValue('foo'); $form = new Form('my-form'); $form-&gt;add($button);","title":"Basic Usage"},{"location":"element/captcha/","text":"Captcha Laminas\\Form\\Element\\Captcha can be used with forms where authenticated users are not necessary, but you want to prevent spam submissions. It is paired with one of the Laminas\\Form\\View\\Helper\\Captcha\\* view helpers that matches the type of CAPTCHA adapter in use. Basic Usage A CAPTCHA adapter must be attached in order for validation to be included in the element's input filter specification. See the laminas-captcha documentation for more information on what adapters are available. use Laminas\\Captcha; use Laminas\\Form\\Element; use Laminas\\Form\\Form; $captcha = new Element\\Captcha('captcha'); $captcha-&gt;setCaptcha(new Captcha\\Dumb()); $captcha-&gt;setLabel('Please verify you are human'); $form = new Form('my-form'); $form-&gt;add($captcha); Here is an example using array notation: use Laminas\\Captcha; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; 'Laminas\\Form\\Element\\Captcha', 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human', 'captcha' =&gt; new Captcha\\Dumb(), ], ]); Public Methods The following methods are specific to the Captcha element; all other methods defined by the parent Element class are also available. Method signature Description setCaptcha(array|Laminas\\Captcha\\AdapterInterface $captcha) : void Set the CAPTCHA adapter for this element. If $captcha is an array, Laminas\\Captcha\\Factory::factory() will be run to create the adapter from the array configuration. getCaptcha() : Laminas\\Captcha\\AdapterInterface Return the CAPTCHA adapter for this element. getInputSpecification() : array Returns a input filter specification, which includes a Laminas\\Filter\\StringTrim filter, and a CAPTCHA validator.","title":"CAPTCHA"},{"location":"element/captcha/#captcha","text":"Laminas\\Form\\Element\\Captcha can be used with forms where authenticated users are not necessary, but you want to prevent spam submissions. It is paired with one of the Laminas\\Form\\View\\Helper\\Captcha\\* view helpers that matches the type of CAPTCHA adapter in use.","title":"Captcha"},{"location":"element/captcha/#basic-usage","text":"A CAPTCHA adapter must be attached in order for validation to be included in the element's input filter specification. See the laminas-captcha documentation for more information on what adapters are available. use Laminas\\Captcha; use Laminas\\Form\\Element; use Laminas\\Form\\Form; $captcha = new Element\\Captcha('captcha'); $captcha-&gt;setCaptcha(new Captcha\\Dumb()); $captcha-&gt;setLabel('Please verify you are human'); $form = new Form('my-form'); $form-&gt;add($captcha); Here is an example using array notation: use Laminas\\Captcha; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; 'Laminas\\Form\\Element\\Captcha', 'name' =&gt; 'captcha', 'options' =&gt; [ 'label' =&gt; 'Please verify you are human', 'captcha' =&gt; new Captcha\\Dumb(), ], ]);","title":"Basic Usage"},{"location":"element/captcha/#public-methods","text":"The following methods are specific to the Captcha element; all other methods defined by the parent Element class are also available. Method signature Description setCaptcha(array|Laminas\\Captcha\\AdapterInterface $captcha) : void Set the CAPTCHA adapter for this element. If $captcha is an array, Laminas\\Captcha\\Factory::factory() will be run to create the adapter from the array configuration. getCaptcha() : Laminas\\Captcha\\AdapterInterface Return the CAPTCHA adapter for this element. getInputSpecification() : array Returns a input filter specification, which includes a Laminas\\Filter\\StringTrim filter, and a CAPTCHA validator.","title":"Public Methods"},{"location":"element/checkbox/","text":"Checkbox Laminas\\Form\\Element\\Checkbox is meant to be paired with the Laminas\\Form\\View\\Helper\\FormCheckbox for HTML inputs with type checkbox. This element adds an InArray validator to its input filter specification in order to validate on the server if the checkbox contains either the checked value or the unchecked value. Basic Usage This element automatically adds a type attribute of value checkbox . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $checkbox = new Element\\Checkbox('checkbox'); $checkbox-&gt;setLabel('A checkbox'); $checkbox-&gt;setUseHiddenElement(true); $checkbox-&gt;setCheckedValue('good'); $checkbox-&gt;setUncheckedValue('bad'); $form = new Form('my-form'); $form-&gt;add($checkbox); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Checkbox::class, 'name' =&gt; 'checkbox', 'options' =&gt; [ 'label' =&gt; 'A checkbox', 'use_hidden_element' =&gt; true, 'checked_value' =&gt; 'good', 'unchecked_value' =&gt; 'bad', ], ]); When creating a checkbox element, setting an attribute of checked will result in the checkbox always being checked, regardless of any data object which might subsequently be bound to the form. The correct way to set the default value of a checkbox is to set the value attribute as for any other element. To have a checkbox checked by default, make the value equal to the checked_value eg: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Checkbox::class, 'name' =&gt; 'checkbox', 'options' =&gt; [ 'label' =&gt; 'A checkbox', 'use_hidden_element' =&gt; true, 'checked_value' =&gt; 'yes', 'unchecked_value' =&gt; 'no', ], 'attributes' =&gt; [ 'value' =&gt; 'yes', ], ]); Public Methods The following methods are specific to the Checkbox element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element of type Checkbox. Accepted options, in addition to the options inherited from Element , are: use_hidden_element , checked_value and unchecked_value , which call setUseHiddenElement() , setCheckedValue() and setUncheckedValue() , respectively. setUseHiddenElement(boolean $useHiddenElement) : void If set to true (which is default), the view helper will generate a hidden element that contains the unchecked value. Therefore, when using custom unchecked value, this option have to be set to true. useHiddenElement() : boolean Return if a hidden element is generated. setCheckedValue(string $checkedValue) : void Set the value to use when the checkbox is checked. getCheckedValue() : string Return the value used when the checkbox is checked. setUncheckedValue(string $uncheckedValue) : void Set the value to use when the checkbox is unchecked. For this to work, you must make sure that use_hidden_element is set to true. getUncheckedValue() : string Return the value used when the checkbox is unchecked. getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Validator\\InArray to validate if the value is one of the checked or unchecked values. isChecked() : boolean Checks if the checkbox is checked. setChecked(bool $value) : void Checks or unchecks the checkbox.","title":"checkbox"},{"location":"element/checkbox/#checkbox","text":"Laminas\\Form\\Element\\Checkbox is meant to be paired with the Laminas\\Form\\View\\Helper\\FormCheckbox for HTML inputs with type checkbox. This element adds an InArray validator to its input filter specification in order to validate on the server if the checkbox contains either the checked value or the unchecked value.","title":"Checkbox"},{"location":"element/checkbox/#basic-usage","text":"This element automatically adds a type attribute of value checkbox . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $checkbox = new Element\\Checkbox('checkbox'); $checkbox-&gt;setLabel('A checkbox'); $checkbox-&gt;setUseHiddenElement(true); $checkbox-&gt;setCheckedValue('good'); $checkbox-&gt;setUncheckedValue('bad'); $form = new Form('my-form'); $form-&gt;add($checkbox); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Checkbox::class, 'name' =&gt; 'checkbox', 'options' =&gt; [ 'label' =&gt; 'A checkbox', 'use_hidden_element' =&gt; true, 'checked_value' =&gt; 'good', 'unchecked_value' =&gt; 'bad', ], ]); When creating a checkbox element, setting an attribute of checked will result in the checkbox always being checked, regardless of any data object which might subsequently be bound to the form. The correct way to set the default value of a checkbox is to set the value attribute as for any other element. To have a checkbox checked by default, make the value equal to the checked_value eg: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Checkbox::class, 'name' =&gt; 'checkbox', 'options' =&gt; [ 'label' =&gt; 'A checkbox', 'use_hidden_element' =&gt; true, 'checked_value' =&gt; 'yes', 'unchecked_value' =&gt; 'no', ], 'attributes' =&gt; [ 'value' =&gt; 'yes', ], ]);","title":"Basic Usage"},{"location":"element/checkbox/#public-methods","text":"The following methods are specific to the Checkbox element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element of type Checkbox. Accepted options, in addition to the options inherited from Element , are: use_hidden_element , checked_value and unchecked_value , which call setUseHiddenElement() , setCheckedValue() and setUncheckedValue() , respectively. setUseHiddenElement(boolean $useHiddenElement) : void If set to true (which is default), the view helper will generate a hidden element that contains the unchecked value. Therefore, when using custom unchecked value, this option have to be set to true. useHiddenElement() : boolean Return if a hidden element is generated. setCheckedValue(string $checkedValue) : void Set the value to use when the checkbox is checked. getCheckedValue() : string Return the value used when the checkbox is checked. setUncheckedValue(string $uncheckedValue) : void Set the value to use when the checkbox is unchecked. For this to work, you must make sure that use_hidden_element is set to true. getUncheckedValue() : string Return the value used when the checkbox is unchecked. getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Validator\\InArray to validate if the value is one of the checked or unchecked values. isChecked() : boolean Checks if the checkbox is checked. setChecked(bool $value) : void Checks or unchecks the checkbox.","title":"Public Methods"},{"location":"element/collection/","text":"Collection Sometimes, you may want to add an input (or a set of inputs) multiple times, either because you don't want to duplicate code, or because you do not know in advance how many elements you will need (in the case of elements dynamically added to a form using Javascript, for instance). For more information about collections, please refer to the form Collections tutorial . Laminas\\Form\\Element\\Collection is meant to be paired with the Laminas\\Form\\View\\Helper\\FormCollection . Basic Usage use Laminas\\Form\\Element; use Laminas\\Form\\Form; $colors = new Element\\Collection('collection'); $colors-&gt;setLabel('Colors'); $colors-&gt;setCount(2); $colors-&gt;setTargetElement(new Element\\Color()); $colors-&gt;setShouldCreateTemplate(true); $form = new Form('my-form'); $form-&gt;add($colors); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Collection::class, 'options' =&gt; [ 'label' =&gt; 'Colors', 'count' =&gt; 2, 'should_create_template' =&gt; true, 'target_element' =&gt; new Element\\Color() ], ]); Public Methods The following methods are specific to the Collection element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element of type Collection. Accepted options, in addition to the options inherited from Element , are: target_element , count , allow_add , allow_remove , should_create_template and template_placeholder . Those option keys respectively call setTargetElement() , setCount() , setAllowAdd() , setAllowRemove() , setShouldCreateTemplate() and setTemplatePlaceholder() . allowObjectBinding(object $object) : bool Checks if the object can be set in this fieldset. setObject(array|Traversable $object) : void Set the object used by the hydrator. In this case the \"object\" is a collection of objects. populateValues(array|Traversable $data) : void Populate values allowValueBinding() : bool Checks if this fieldset can bind data setCount($count) : void Defines how many times the target element will be initially rendered by the Laminas\\Form\\View\\Helper\\FormCollection view helper. getCount() : integer Return the number of times the target element will be initially rendered by the Laminas\\Form\\View\\Helper\\FormCollection view helper. setTargetElement($elementOrFieldset) : void This function either takes an Laminas\\Form\\ElementInterface , Laminas\\Form\\FieldsetInterface instance or an array to pass to the form factory. When the Collection element will be validated, the input filter will be retrieved from this target element and be used to validate each element in the collection. getTargetElement() : ElementInterface|null Return the target element used by the collection. setAllowAdd($allowAdd) : void If allowAdd is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will also be validated and retrieved. allowAdd() : boolean Return if new elements can be dynamically added in the collection. setAllowRemove($allowRemove) : void If allowRemove is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will be allowed to be removed. allowRemove() : boolean Return if new elements can be dynamically removed from the collection. setShouldCreateTemplate($shouldCreateTemplate) : void If shouldCreateTemplate is set to true (defaults to false ), a &lt;span&gt; element will be generated by the Laminas\\Form\\View\\Helper\\FormCollection view helper. This non-semantic span element contains a single data-template HTML5 attribute whose value is the whole HTML to copy to create a new element in the form. The template is indexed using the templatePlaceholder value. shouldCreateTemplate() : boolean Return if a template should be created. setTemplatePlaceholder($templatePlaceholder) : void Set the template placeholder (defaults to __index__ ) used to index element in the template. getTemplatePlaceholder() : string Returns the template placeholder used to index element in the template. getTemplateElement() : null|ElementInterface|FieldsetInterface Get a template element used for rendering purposes only prepareElement : void Prepare the collection by adding a dummy template element if the user want one prepareFieldset() : void If both count and targetElement are set, add them to the fieldset","title":"Collection"},{"location":"element/collection/#collection","text":"Sometimes, you may want to add an input (or a set of inputs) multiple times, either because you don't want to duplicate code, or because you do not know in advance how many elements you will need (in the case of elements dynamically added to a form using Javascript, for instance). For more information about collections, please refer to the form Collections tutorial . Laminas\\Form\\Element\\Collection is meant to be paired with the Laminas\\Form\\View\\Helper\\FormCollection .","title":"Collection"},{"location":"element/collection/#basic-usage","text":"use Laminas\\Form\\Element; use Laminas\\Form\\Form; $colors = new Element\\Collection('collection'); $colors-&gt;setLabel('Colors'); $colors-&gt;setCount(2); $colors-&gt;setTargetElement(new Element\\Color()); $colors-&gt;setShouldCreateTemplate(true); $form = new Form('my-form'); $form-&gt;add($colors); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Collection::class, 'options' =&gt; [ 'label' =&gt; 'Colors', 'count' =&gt; 2, 'should_create_template' =&gt; true, 'target_element' =&gt; new Element\\Color() ], ]);","title":"Basic Usage"},{"location":"element/collection/#public-methods","text":"The following methods are specific to the Collection element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element of type Collection. Accepted options, in addition to the options inherited from Element , are: target_element , count , allow_add , allow_remove , should_create_template and template_placeholder . Those option keys respectively call setTargetElement() , setCount() , setAllowAdd() , setAllowRemove() , setShouldCreateTemplate() and setTemplatePlaceholder() . allowObjectBinding(object $object) : bool Checks if the object can be set in this fieldset. setObject(array|Traversable $object) : void Set the object used by the hydrator. In this case the \"object\" is a collection of objects. populateValues(array|Traversable $data) : void Populate values allowValueBinding() : bool Checks if this fieldset can bind data setCount($count) : void Defines how many times the target element will be initially rendered by the Laminas\\Form\\View\\Helper\\FormCollection view helper. getCount() : integer Return the number of times the target element will be initially rendered by the Laminas\\Form\\View\\Helper\\FormCollection view helper. setTargetElement($elementOrFieldset) : void This function either takes an Laminas\\Form\\ElementInterface , Laminas\\Form\\FieldsetInterface instance or an array to pass to the form factory. When the Collection element will be validated, the input filter will be retrieved from this target element and be used to validate each element in the collection. getTargetElement() : ElementInterface|null Return the target element used by the collection. setAllowAdd($allowAdd) : void If allowAdd is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will also be validated and retrieved. allowAdd() : boolean Return if new elements can be dynamically added in the collection. setAllowRemove($allowRemove) : void If allowRemove is set to true (which is the default), new elements added dynamically in the form (using JavaScript, for instance) will be allowed to be removed. allowRemove() : boolean Return if new elements can be dynamically removed from the collection. setShouldCreateTemplate($shouldCreateTemplate) : void If shouldCreateTemplate is set to true (defaults to false ), a &lt;span&gt; element will be generated by the Laminas\\Form\\View\\Helper\\FormCollection view helper. This non-semantic span element contains a single data-template HTML5 attribute whose value is the whole HTML to copy to create a new element in the form. The template is indexed using the templatePlaceholder value. shouldCreateTemplate() : boolean Return if a template should be created. setTemplatePlaceholder($templatePlaceholder) : void Set the template placeholder (defaults to __index__ ) used to index element in the template. getTemplatePlaceholder() : string Returns the template placeholder used to index element in the template. getTemplateElement() : null|ElementInterface|FieldsetInterface Get a template element used for rendering purposes only prepareElement : void Prepare the collection by adding a dummy template element if the user want one prepareFieldset() : void If both count and targetElement are set, add them to the fieldset","title":"Public Methods"},{"location":"element/color/","text":"Color Laminas\\Form\\Element\\Color is meant to be paired with Laminas\\Form\\View\\Helper\\FormColor for HTML5 inputs with type \"color\" . This element adds filters and a Regex validator to its input filter specification in order to validate an HTML5 valid simple color value on the server. Basic Usage This element automatically adds a type attribute of value color . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $color = new Element\\Color('color'); $color-&gt;setLabel('Background color'); $form = new Form('my-form'); $form-&gt;add($color); The following uses array notation instead: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Color::class, 'name' =&gt; 'color', 'options' =&gt; [ 'label' =&gt; 'Background color', ], ]); Public Methods The following methods are specific to the Color element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and Laminas\\Filter\\StringToLower filters, and a Laminas\\Validator\\Regex to validate the RGB hex format.","title":"color"},{"location":"element/color/#color","text":"Laminas\\Form\\Element\\Color is meant to be paired with Laminas\\Form\\View\\Helper\\FormColor for HTML5 inputs with type \"color\" . This element adds filters and a Regex validator to its input filter specification in order to validate an HTML5 valid simple color value on the server.","title":"Color"},{"location":"element/color/#basic-usage","text":"This element automatically adds a type attribute of value color . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $color = new Element\\Color('color'); $color-&gt;setLabel('Background color'); $form = new Form('my-form'); $form-&gt;add($color); The following uses array notation instead: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Color::class, 'name' =&gt; 'color', 'options' =&gt; [ 'label' =&gt; 'Background color', ], ]);","title":"Basic Usage"},{"location":"element/color/#public-methods","text":"The following methods are specific to the Color element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and Laminas\\Filter\\StringToLower filters, and a Laminas\\Validator\\Regex to validate the RGB hex format.","title":"Public Methods"},{"location":"element/csrf/","text":"Csrf Laminas\\Form\\Element\\Csrf pairs with the FormHidden helper to provide protection from CSRF attacks on forms, ensuring the data is submitted by the user session that generated the form and not by a rogue script. Protection is achieved by adding a hash element to a form and verifying it when the form is submitted. Basic Usage This element automatically adds a type attribute of value hidden . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $csrf = new Element\\Csrf('csrf'); $form = new Form('my-form'); $form-&gt;add($csrf); You can change the options of the CSRF validator using the setCsrfValidatorOptions() function, or by using the csrf_options key. Here is an example using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'csrf', 'options' =&gt; [ 'csrf_options' =&gt; [ 'timeout' =&gt; 600, ], ], ]); Multiple CSRF elements must be uniquely named If you are using more than one form on a page, and each contains its own CSRF element, you will need to make sure that each form uniquely names its element; if you do not, it's possible for the value of one to override the other within the server-side session storage, leading to the inability to validate one or more of the forms on your page. We suggest prefixing the element name with the form's name or function: login_csrf , registration_csrf , etc. Public Methods The following methods are specific to the Csrf element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes a Laminas\\Filter\\StringTrim filter and Laminas\\Validator\\Csrf to validate the CSRF value. setCsrfValidatorOptions(array $options) : void Set the options that are used by the CSRF validator. getCsrfValidatorOptions() : array Get the options that are used by the CSRF validator. setCsrfValidator(Laminas\\Validator\\Csrf $validator) : void Override the default CSRF validator by setting another one. getCsrfValidator() : Laminas\\Validator\\Csrf Get the CSRF validator.","title":"CSRF"},{"location":"element/csrf/#csrf","text":"Laminas\\Form\\Element\\Csrf pairs with the FormHidden helper to provide protection from CSRF attacks on forms, ensuring the data is submitted by the user session that generated the form and not by a rogue script. Protection is achieved by adding a hash element to a form and verifying it when the form is submitted.","title":"Csrf"},{"location":"element/csrf/#basic-usage","text":"This element automatically adds a type attribute of value hidden . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $csrf = new Element\\Csrf('csrf'); $form = new Form('my-form'); $form-&gt;add($csrf); You can change the options of the CSRF validator using the setCsrfValidatorOptions() function, or by using the csrf_options key. Here is an example using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Csrf::class, 'name' =&gt; 'csrf', 'options' =&gt; [ 'csrf_options' =&gt; [ 'timeout' =&gt; 600, ], ], ]);","title":"Basic Usage"},{"location":"element/csrf/#public-methods","text":"The following methods are specific to the Csrf element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes a Laminas\\Filter\\StringTrim filter and Laminas\\Validator\\Csrf to validate the CSRF value. setCsrfValidatorOptions(array $options) : void Set the options that are used by the CSRF validator. getCsrfValidatorOptions() : array Get the options that are used by the CSRF validator. setCsrfValidator(Laminas\\Validator\\Csrf $validator) : void Override the default CSRF validator by setting another one. getCsrfValidator() : Laminas\\Validator\\Csrf Get the CSRF validator.","title":"Public Methods"},{"location":"element/date-time-local/","text":"DateTimeLocal Laminas\\Form\\Element\\DateTimeLocal is meant to be paired with the FormDateTimeLocal helper for HTML5 inputs with type \"datetime-local\" . This element adds filters and validators to its input filter specification in order to validate a local datetime input value on the server. Basic Usage This element automatically adds a type attribute of value datetime-local . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $dateTimeLocal = new Element\\DateTimeLocal('appointment-date-time'); $dateTimeLocal-&gt;setLabel('Appointment Date'); $dateTimeLocal-&gt;setAttributes([ 'min' =&gt; '2010-01-01T00:00:00', 'max' =&gt; '2020-01-01T00:00:00', 'step' =&gt; '1', // minutes; default step interval is 1 min ]); $dateTimeLocal-&gt;setOptions([ 'format' =&gt; 'Y-m-d\\TH:i', ]); $form = new Form('my-form'); $form-&gt;add($dateTimeLocal); Here is with the array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\DateTimeLocal::class, 'name' =&gt; 'appointment-date-time', 'options' =&gt; [ 'label' =&gt; 'Appointment Date', 'format' =&gt; 'Y-m-d\\TH:i' ], 'attributes' =&gt; [ 'min' =&gt; '2010-01-01T00:00:00', 'max' =&gt; '2020-01-01T00:00:00', 'step' =&gt; '1', // minutes; default step interval is 1 min ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The following methods are specific to the DateTimeLocal element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime::getInputSpecification() definition for more information.","title":"datetime-local"},{"location":"element/date-time-local/#datetimelocal","text":"Laminas\\Form\\Element\\DateTimeLocal is meant to be paired with the FormDateTimeLocal helper for HTML5 inputs with type \"datetime-local\" . This element adds filters and validators to its input filter specification in order to validate a local datetime input value on the server.","title":"DateTimeLocal"},{"location":"element/date-time-local/#basic-usage","text":"This element automatically adds a type attribute of value datetime-local . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $dateTimeLocal = new Element\\DateTimeLocal('appointment-date-time'); $dateTimeLocal-&gt;setLabel('Appointment Date'); $dateTimeLocal-&gt;setAttributes([ 'min' =&gt; '2010-01-01T00:00:00', 'max' =&gt; '2020-01-01T00:00:00', 'step' =&gt; '1', // minutes; default step interval is 1 min ]); $dateTimeLocal-&gt;setOptions([ 'format' =&gt; 'Y-m-d\\TH:i', ]); $form = new Form('my-form'); $form-&gt;add($dateTimeLocal); Here is with the array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\DateTimeLocal::class, 'name' =&gt; 'appointment-date-time', 'options' =&gt; [ 'label' =&gt; 'Appointment Date', 'format' =&gt; 'Y-m-d\\TH:i' ], 'attributes' =&gt; [ 'min' =&gt; '2010-01-01T00:00:00', 'max' =&gt; '2020-01-01T00:00:00', 'step' =&gt; '1', // minutes; default step interval is 1 min ], ]);","title":"Basic Usage"},{"location":"element/date-time-local/#public-methods","text":"The following methods are specific to the DateTimeLocal element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime::getInputSpecification() definition for more information.","title":"Public Methods"},{"location":"element/date-time/","text":"DateTime Laminas\\Form\\Element\\DateTime is meant to be paired with the FormDateTime helper for HTML5 inputs with type \"datetime\" . This element adds filters and validators to its input filter specification in order to validate HTML5 datetime input values on the server. Basic Usage This element automatically adds a type attribute of value datetime . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $dateTime = new Element\\DateTime('appointment-date-time'); $dateTime-&gt;setLabel('Appointment Date/Time'); $dateTime-&gt;setAttributes([ 'min' =&gt; '2010-01-01T00:00:00Z', 'max' =&gt; '2020-01-01T00:00:00Z', 'step' =&gt; '1', // minutes; default step interval is 1 min ]); $dateTime-&gt;setOptions([ 'format' =&gt; 'Y-m-d\\TH:iP' ]); $form = new Form('my-form'); $form-&gt;add($dateTime); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\DateTime::class, 'name' =&gt; 'appointment-date-time', 'options' =&gt; [ 'label' =&gt; 'Appointment Date/Time', 'format' =&gt; 'Y-m-d\\TH:iP', ], 'attributes' =&gt; [ 'min' =&gt; '2010-01-01T00:00:00Z', 'max' =&gt; '2020-01-01T00:00:00Z', 'step' =&gt; '1', // minutes; default step interval is 1 min ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The following methods are specific to the DateTime element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array See write-up below. setOptions(array $options) : void Set options for an element of type DateTime . The accepted option, in addition to the inherited options of Laminas\\Form\\Element is format , which calls setFormat() . setFormat(string $format) : void Sets the format used to validate the value. Accepts a PHP DateTime compatible string. getFormat() : string Return the PHP DateTime format used to validate the value. getInputSpecification() returns an input filter specification, which includes the StringTrim filter, and appropriate validators based on the values from the min , max , and step attributes, as well as the format option, per the following: If the min attribute is set, a Laminas\\Validator\\GreaterThan validator will be added to ensure the date value is greater than the minimum value. If the max attribute is set, a Laminas\\Validator\\LessThanValidator validator will be added to ensure the date value is less than the maximum value. If the step attribute is set to \"any\", step validations will be skipped. Otherwise, a Laminas\\Validator\\DateStep validator will be added to ensure the date value is within a certain interval of minutes (default is 1 minute). The input filter specification also includes a Laminas\\Validator\\Date validator to ensure the format of the value. If the format option is set, that format will be used. Otherwise the default format will be used.","title":"datetime"},{"location":"element/date-time/#datetime","text":"Laminas\\Form\\Element\\DateTime is meant to be paired with the FormDateTime helper for HTML5 inputs with type \"datetime\" . This element adds filters and validators to its input filter specification in order to validate HTML5 datetime input values on the server.","title":"DateTime"},{"location":"element/date-time/#basic-usage","text":"This element automatically adds a type attribute of value datetime . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $dateTime = new Element\\DateTime('appointment-date-time'); $dateTime-&gt;setLabel('Appointment Date/Time'); $dateTime-&gt;setAttributes([ 'min' =&gt; '2010-01-01T00:00:00Z', 'max' =&gt; '2020-01-01T00:00:00Z', 'step' =&gt; '1', // minutes; default step interval is 1 min ]); $dateTime-&gt;setOptions([ 'format' =&gt; 'Y-m-d\\TH:iP' ]); $form = new Form('my-form'); $form-&gt;add($dateTime); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\DateTime::class, 'name' =&gt; 'appointment-date-time', 'options' =&gt; [ 'label' =&gt; 'Appointment Date/Time', 'format' =&gt; 'Y-m-d\\TH:iP', ], 'attributes' =&gt; [ 'min' =&gt; '2010-01-01T00:00:00Z', 'max' =&gt; '2020-01-01T00:00:00Z', 'step' =&gt; '1', // minutes; default step interval is 1 min ], ]);","title":"Basic Usage"},{"location":"element/date-time/#public-methods","text":"The following methods are specific to the DateTime element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array See write-up below. setOptions(array $options) : void Set options for an element of type DateTime . The accepted option, in addition to the inherited options of Laminas\\Form\\Element is format , which calls setFormat() . setFormat(string $format) : void Sets the format used to validate the value. Accepts a PHP DateTime compatible string. getFormat() : string Return the PHP DateTime format used to validate the value. getInputSpecification() returns an input filter specification, which includes the StringTrim filter, and appropriate validators based on the values from the min , max , and step attributes, as well as the format option, per the following: If the min attribute is set, a Laminas\\Validator\\GreaterThan validator will be added to ensure the date value is greater than the minimum value. If the max attribute is set, a Laminas\\Validator\\LessThanValidator validator will be added to ensure the date value is less than the maximum value. If the step attribute is set to \"any\", step validations will be skipped. Otherwise, a Laminas\\Validator\\DateStep validator will be added to ensure the date value is within a certain interval of minutes (default is 1 minute). The input filter specification also includes a Laminas\\Validator\\Date validator to ensure the format of the value. If the format option is set, that format will be used. Otherwise the default format will be used.","title":"Public Methods"},{"location":"element/date/","text":"Date Laminas\\Form\\Element\\Date is meant to be paired with the FormDate helper for HTML5 inputs with type \"date\" . This element adds filters and validators to its input filter specification in order to validate HTML5 date input values on the server. Basic Usage This element automatically adds a type attribute of value date . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $date = new Element\\Date('appointment-date'); $date-&gt;setLabel('Appointment Date'); $date-&gt;setAttributes([ 'min' =&gt; '2012-01-01', 'max' =&gt; '2020-01-01', 'step' =&gt; '1', // days; default step interval is 1 day ]); $date-&gt;setOptions([ 'format' =&gt; 'Y-m-d', ]); $form = new Form('my-form'); $form-&gt;add($date); The following uses array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Date::class, 'name' =&gt; 'appointment-date', 'options' =&gt; [ 'label' =&gt; 'Appointment Date', 'format' =&gt; 'Y-m-d', ], 'attributes' =&gt; [ 'min' =&gt; '2012-01-01', 'max' =&gt; '2020-01-01', 'step' =&gt; '1', // days; default step interval is 1 day ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The following methods are specific to the Date element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime::getInputSpecification() definition for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of days (default is 1 day).","title":"date"},{"location":"element/date/#date","text":"Laminas\\Form\\Element\\Date is meant to be paired with the FormDate helper for HTML5 inputs with type \"date\" . This element adds filters and validators to its input filter specification in order to validate HTML5 date input values on the server.","title":"Date"},{"location":"element/date/#basic-usage","text":"This element automatically adds a type attribute of value date . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $date = new Element\\Date('appointment-date'); $date-&gt;setLabel('Appointment Date'); $date-&gt;setAttributes([ 'min' =&gt; '2012-01-01', 'max' =&gt; '2020-01-01', 'step' =&gt; '1', // days; default step interval is 1 day ]); $date-&gt;setOptions([ 'format' =&gt; 'Y-m-d', ]); $form = new Form('my-form'); $form-&gt;add($date); The following uses array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Date::class, 'name' =&gt; 'appointment-date', 'options' =&gt; [ 'label' =&gt; 'Appointment Date', 'format' =&gt; 'Y-m-d', ], 'attributes' =&gt; [ 'min' =&gt; '2012-01-01', 'max' =&gt; '2020-01-01', 'step' =&gt; '1', // days; default step interval is 1 day ], ]);","title":"Basic Usage"},{"location":"element/date/#public-methods","text":"The following methods are specific to the Date element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime::getInputSpecification() definition for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of days (default is 1 day).","title":"Public Methods"},{"location":"element/element/","text":"Element Base Class Laminas\\Form\\Element is a base class for all specialized elements and Laminas\\Form\\Fieldset . Basic Usage At the bare minimum, each element or fieldset requires a name. You will also typically provide some attributes to hint to the view layer how it might render the item. use Laminas\\Form\\Element; use Laminas\\Form\\Form; $username = new Element\\Text('username'); $username-&gt;setLabel('Username'); $username-&gt;setAttributes([ 'class' =&gt; 'username', 'size' =&gt; '30', ]); $password = new Element\\Password('password'); $password-&gt;setLabel('Password') $password-&gt;setAttributes([ 'size' =&gt; '30', ]); $form = new Form('my-form'); $form-&gt;add($username); $form-&gt;add($password); Public Methods Method signature Description setName(string $name) : void Set the name for this element. getName() : string Return the name for this element. setValue(string $value) : void Set the value for this element. getValue() : string Return the value for this element. setLabel(string $label) : void Set the label content for this element. getLabel() : string Return the label content for this element. setLabelAttributes(array $labelAttributes) : void Set the attributes to use with the label. getLabelAttributes() : array Return the attributes to use with the label. setLabelOptions(array $labelOptions) : void Set label specific options. getLabelOptions() : array Return the label specific options. setOptions(array $options) : void Set options for an element. Accepted options are: label , label_attributes\" , label_options , which call setLabel , setLabelAttributes and setLabelOptions , respectively. getOptions() : array Get defined options for an element getOption(string $option) : null|mixed Return the specified option, if defined. If it's not defined, returns null. setAttribute(string $key, mixed $value) : void Set a single element attribute. getAttribute(string $key) : mixed Retrieve a single element attribute. removeAttribute(string $key) : void Remove a single attribute hasAttribute(string $key) : boolean Check if a specific attribute exists for this element. setAttributes(array|Traversable $arrayOrTraversable) : void Set many attributes at once. Implementation will decide if this will overwrite or merge. getAttributes() : array|Traversable Retrieve all attributes at once. removeAttributes(array $keys) : void Remove many attributes at once clearAttributes() : void Clear all attributes for this element. setMessages(array|Traversable $messages) : void Set a list of messages to report when validation fails. getMessages() : array|Traversable Returns a list of validation failure messages, if any.","title":"Element"},{"location":"element/element/#element-base-class","text":"Laminas\\Form\\Element is a base class for all specialized elements and Laminas\\Form\\Fieldset .","title":"Element Base Class"},{"location":"element/element/#basic-usage","text":"At the bare minimum, each element or fieldset requires a name. You will also typically provide some attributes to hint to the view layer how it might render the item. use Laminas\\Form\\Element; use Laminas\\Form\\Form; $username = new Element\\Text('username'); $username-&gt;setLabel('Username'); $username-&gt;setAttributes([ 'class' =&gt; 'username', 'size' =&gt; '30', ]); $password = new Element\\Password('password'); $password-&gt;setLabel('Password') $password-&gt;setAttributes([ 'size' =&gt; '30', ]); $form = new Form('my-form'); $form-&gt;add($username); $form-&gt;add($password);","title":"Basic Usage"},{"location":"element/element/#public-methods","text":"Method signature Description setName(string $name) : void Set the name for this element. getName() : string Return the name for this element. setValue(string $value) : void Set the value for this element. getValue() : string Return the value for this element. setLabel(string $label) : void Set the label content for this element. getLabel() : string Return the label content for this element. setLabelAttributes(array $labelAttributes) : void Set the attributes to use with the label. getLabelAttributes() : array Return the attributes to use with the label. setLabelOptions(array $labelOptions) : void Set label specific options. getLabelOptions() : array Return the label specific options. setOptions(array $options) : void Set options for an element. Accepted options are: label , label_attributes\" , label_options , which call setLabel , setLabelAttributes and setLabelOptions , respectively. getOptions() : array Get defined options for an element getOption(string $option) : null|mixed Return the specified option, if defined. If it's not defined, returns null. setAttribute(string $key, mixed $value) : void Set a single element attribute. getAttribute(string $key) : mixed Retrieve a single element attribute. removeAttribute(string $key) : void Remove a single attribute hasAttribute(string $key) : boolean Check if a specific attribute exists for this element. setAttributes(array|Traversable $arrayOrTraversable) : void Set many attributes at once. Implementation will decide if this will overwrite or merge. getAttributes() : array|Traversable Retrieve all attributes at once. removeAttributes(array $keys) : void Remove many attributes at once clearAttributes() : void Clear all attributes for this element. setMessages(array|Traversable $messages) : void Set a list of messages to report when validation fails. getMessages() : array|Traversable Returns a list of validation failure messages, if any.","title":"Public Methods"},{"location":"element/email/","text":"Email Laminas\\Form\\Element\\Email is meant to be paired with the FormEmail helper for HTML5 inputs with type \"email\" . This element adds filters and validators to its input filter specification in order to validate HTML5 valid email address on the server. Basic Usage This element automatically adds a type attribute of value email . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); // Single email address: $email = new Element\\Email('email'); $email-&gt;setLabel('Email Address') $form-&gt;add($email); // Comma separated list of emails: $emails = new Element\\Email('emails'); $emails-&gt;setLabel('Email Addresses'); $emails-&gt;setAttribute('multiple', true); $form-&gt;add($emails); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); // Single email address: $form-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Email Address', ], ]); // Comma separated list of emails: $form-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'emails', 'options' =&gt; [ 'label' =&gt; 'Email Addresses', ], 'attributes' =&gt; [ 'multiple' =&gt; true, ], ]); Set multiple attribute before calling prepare Note: the multiple attribute should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The following methods are specific to the Email element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array See description below. setValidator(ValidatorInterface $validator) : void Sets the primary validator to use for this element. getValidator() : ValidatorInterface Get the primary validator. setEmailValidator(ValidatorInterface $validator) : void Sets the email validator to use for multiple or single email addresses. getEmailValidator() : void Get the email validator to use for multiple or single email addresses. The default Regex validator in use is to match that of the browser validation, but you are free to set a different (more strict) email validator such as Laminas\\Validator\\Email if you wish. getInputSpecification() returns an input filter specification, which includes a Laminas\\Filter\\StringTrim filter, and a validator based on the multiple attribute: If the multiple attribute is unset or false , a Laminas\\Validator\\Regex validator will be added to validate a single email address. If the multiple attribute is true , a Laminas\\Validator\\Explode validator will be added to ensure the input string value is split by commas before validating each email address with Laminas\\Validator\\Regex .","title":"email"},{"location":"element/email/#email","text":"Laminas\\Form\\Element\\Email is meant to be paired with the FormEmail helper for HTML5 inputs with type \"email\" . This element adds filters and validators to its input filter specification in order to validate HTML5 valid email address on the server.","title":"Email"},{"location":"element/email/#basic-usage","text":"This element automatically adds a type attribute of value email . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); // Single email address: $email = new Element\\Email('email'); $email-&gt;setLabel('Email Address') $form-&gt;add($email); // Comma separated list of emails: $emails = new Element\\Email('emails'); $emails-&gt;setLabel('Email Addresses'); $emails-&gt;setAttribute('multiple', true); $form-&gt;add($emails); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); // Single email address: $form-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'email', 'options' =&gt; [ 'label' =&gt; 'Email Address', ], ]); // Comma separated list of emails: $form-&gt;add([ 'type' =&gt; Element\\Email::class, 'name' =&gt; 'emails', 'options' =&gt; [ 'label' =&gt; 'Email Addresses', ], 'attributes' =&gt; [ 'multiple' =&gt; true, ], ]);","title":"Basic Usage"},{"location":"element/email/#public-methods","text":"The following methods are specific to the Email element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array See description below. setValidator(ValidatorInterface $validator) : void Sets the primary validator to use for this element. getValidator() : ValidatorInterface Get the primary validator. setEmailValidator(ValidatorInterface $validator) : void Sets the email validator to use for multiple or single email addresses. getEmailValidator() : void Get the email validator to use for multiple or single email addresses. The default Regex validator in use is to match that of the browser validation, but you are free to set a different (more strict) email validator such as Laminas\\Validator\\Email if you wish. getInputSpecification() returns an input filter specification, which includes a Laminas\\Filter\\StringTrim filter, and a validator based on the multiple attribute: If the multiple attribute is unset or false , a Laminas\\Validator\\Regex validator will be added to validate a single email address. If the multiple attribute is true , a Laminas\\Validator\\Explode validator will be added to ensure the input string value is split by commas before validating each email address with Laminas\\Validator\\Regex .","title":"Public Methods"},{"location":"element/file/","text":"File Laminas\\Form\\Element\\File represents a form file input and provides a default input specification with a type of FileInput (important for handling validators and filters correctly). It is intended for use with the FormFile view helper. Basic Usage This element automatically adds a type attribute of value file . It will also set the form's enctype to multipart/form-data during $form-&gt;prepare() . use Laminas\\Form\\Element; use Laminas\\Form\\Form; // Single file upload: $file = new Element\\File('file'); $file-&gt;setLabel('Single file input'); // HTML5 multiple file upload: $multiFile = new Element\\File('multi-file'); $multiFile-&gt;setLabel('Multi file input'); $multiFile-&gt;setAttribute('multiple', true); $form = new Form('my-file'); $form-&gt;add($file); $form-&gt;add($multiFile);","title":"file"},{"location":"element/file/#file","text":"Laminas\\Form\\Element\\File represents a form file input and provides a default input specification with a type of FileInput (important for handling validators and filters correctly). It is intended for use with the FormFile view helper.","title":"File"},{"location":"element/file/#basic-usage","text":"This element automatically adds a type attribute of value file . It will also set the form's enctype to multipart/form-data during $form-&gt;prepare() . use Laminas\\Form\\Element; use Laminas\\Form\\Form; // Single file upload: $file = new Element\\File('file'); $file-&gt;setLabel('Single file input'); // HTML5 multiple file upload: $multiFile = new Element\\File('multi-file'); $multiFile-&gt;setLabel('Multi file input'); $multiFile-&gt;setAttribute('multiple', true); $form = new Form('my-file'); $form-&gt;add($file); $form-&gt;add($multiFile);","title":"Basic Usage"},{"location":"element/hidden/","text":"Hidden Laminas\\Form\\Element\\Hidden represents a hidden form input. It can be used with the FormHidden view helper. Basic Usage This element automatically adds a type attribute of value hidden . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $hidden = new Element\\Hidden('my-hidden'); $hidden-&gt;setValue('foo'); $form = new Form('my-form'); $form-&gt;add($hidden); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Hidden::class, 'name' =&gt; 'my-hidden', 'attributes' =&gt; [ 'value' =&gt; 'foo', ], ]);","title":"hidden"},{"location":"element/hidden/#hidden","text":"Laminas\\Form\\Element\\Hidden represents a hidden form input. It can be used with the FormHidden view helper.","title":"Hidden"},{"location":"element/hidden/#basic-usage","text":"This element automatically adds a type attribute of value hidden . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $hidden = new Element\\Hidden('my-hidden'); $hidden-&gt;setValue('foo'); $form = new Form('my-form'); $form-&gt;add($hidden); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Hidden::class, 'name' =&gt; 'my-hidden', 'attributes' =&gt; [ 'value' =&gt; 'foo', ], ]);","title":"Basic Usage"},{"location":"element/image/","text":"Image Laminas\\Form\\Element\\Image represents a image button form input. It can be used with the FormImage view helper. Basic Usage This element automatically adds a type attribute of value image . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $image = new Element\\Image('my-image'); $image-&gt;setAttribute('src', 'http://my.image.url'); // Src attribute is required $form = new Form('my-form'); $form-&gt;add($image);","title":"image"},{"location":"element/image/#image","text":"Laminas\\Form\\Element\\Image represents a image button form input. It can be used with the FormImage view helper.","title":"Image"},{"location":"element/image/#basic-usage","text":"This element automatically adds a type attribute of value image . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $image = new Element\\Image('my-image'); $image-&gt;setAttribute('src', 'http://my.image.url'); // Src attribute is required $form = new Form('my-form'); $form-&gt;add($image);","title":"Basic Usage"},{"location":"element/intro/","text":"Form Elements A set of specialized elements are provided for accomplishing application-centric tasks. These include several HTML5 input elements with matching server-side validators, the Csrf element (to prevent Cross Site Request Forgery attacks), and the Captcha element (to display and validate CAPTCHAs ). A Factory is provided to facilitate creation of elements, fieldsets, forms, and the related input filter. See the quick start for more information.","title":"Introduction"},{"location":"element/intro/#form-elements","text":"A set of specialized elements are provided for accomplishing application-centric tasks. These include several HTML5 input elements with matching server-side validators, the Csrf element (to prevent Cross Site Request Forgery attacks), and the Captcha element (to display and validate CAPTCHAs ). A Factory is provided to facilitate creation of elements, fieldsets, forms, and the related input filter. See the quick start for more information.","title":"Form Elements"},{"location":"element/month-select/","text":"Month Select Laminas\\Form\\Element\\MonthSelect is meant to be paired with FormMonthSelect view helper. This element creates two select elements, where the first one is populated with months and the second is populated with years. By default, it sets 100 years in the past for the year element, starting with the current year. Basic Usage use Laminas\\Form\\Element; use Laminas\\Form\\Form; $monthYear = new Element\\MonthSelect('monthyear'); $monthYear-&gt;setLabel('Select a month and a year'); $monthYear-&gt;setMinYear(1986); $form = new Form('dateselect'); $form-&gt;add($monthYear); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('dateselect'); $form-&gt;add([ 'type' =&gt; Element\\MonthSelect::class, 'name' =&gt; 'monthyear', 'options' =&gt; [ 'label' =&gt; 'Select a month and a year', 'min_year' =&gt; 1986, ], ]); Public Methods The following methods are specific to the MonthSelect element; all other methods defined by the parent Element class are also available. Method signature Description getMonthElement() : Laminas\\Form\\Element\\Select Returns the Select element that is used for the months part. getYearElement() : Laminas\\Form\\Element\\Select Returns the Select element that is used for the years part. setMonthAttributes(array $monthAttributes) : void Set attributes on the Select element that is used for the months part. getMonthAttributes() : array Get attributes on the Select element that is used for the months part. setYearAttributes(array $yearAttributes) : void Set attributes on the Select element that is used for the years part. getYearAttributes() : array Get attributes on the Select element that is used for the years part. setMinYear(int $minYear) : void Set the minimum year. getMinYear() : int Get the minimum year. setMaxYear(int $maxYear) : void Set the maximum year. getMaxYear() : int Get the maximum year. setValue(mixed $value) : void Set the value for the MonthSelect element. If the value is an instance of PHP's DateTime , it will use the month and year values from that date. Otherwise, the value should be an associative array with the month key for the month value, and with the year key for the year value.","title":"MonthSelect"},{"location":"element/month-select/#month-select","text":"Laminas\\Form\\Element\\MonthSelect is meant to be paired with FormMonthSelect view helper. This element creates two select elements, where the first one is populated with months and the second is populated with years. By default, it sets 100 years in the past for the year element, starting with the current year.","title":"Month Select"},{"location":"element/month-select/#basic-usage","text":"use Laminas\\Form\\Element; use Laminas\\Form\\Form; $monthYear = new Element\\MonthSelect('monthyear'); $monthYear-&gt;setLabel('Select a month and a year'); $monthYear-&gt;setMinYear(1986); $form = new Form('dateselect'); $form-&gt;add($monthYear); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('dateselect'); $form-&gt;add([ 'type' =&gt; Element\\MonthSelect::class, 'name' =&gt; 'monthyear', 'options' =&gt; [ 'label' =&gt; 'Select a month and a year', 'min_year' =&gt; 1986, ], ]);","title":"Basic Usage"},{"location":"element/month-select/#public-methods","text":"The following methods are specific to the MonthSelect element; all other methods defined by the parent Element class are also available. Method signature Description getMonthElement() : Laminas\\Form\\Element\\Select Returns the Select element that is used for the months part. getYearElement() : Laminas\\Form\\Element\\Select Returns the Select element that is used for the years part. setMonthAttributes(array $monthAttributes) : void Set attributes on the Select element that is used for the months part. getMonthAttributes() : array Get attributes on the Select element that is used for the months part. setYearAttributes(array $yearAttributes) : void Set attributes on the Select element that is used for the years part. getYearAttributes() : array Get attributes on the Select element that is used for the years part. setMinYear(int $minYear) : void Set the minimum year. getMinYear() : int Get the minimum year. setMaxYear(int $maxYear) : void Set the maximum year. getMaxYear() : int Get the maximum year. setValue(mixed $value) : void Set the value for the MonthSelect element. If the value is an instance of PHP's DateTime , it will use the month and year values from that date. Otherwise, the value should be an associative array with the month key for the month value, and with the year key for the year value.","title":"Public Methods"},{"location":"element/month/","text":"Month Laminas\\Form\\Element\\Month is meant to be paired with the FormMonth helper for HTML5 inputs with type \"month\" . This element adds filters and validators to its input filter specification in order to validate HTML5 month input values on the server. Basic Usage This element automatically adds a type attribute of value month . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $month = new Element\\Month('month'); $month-&gt;setLabel('Month'); $month-&gt;setAttributes([ 'min' =&gt; '2012-01', 'max' =&gt; '2020-01', 'step' =&gt; '1', // months; default step interval is 1 month ]); $form = new Form('my-form'); $form-&gt;add($month); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Month::class, 'name' =&gt; 'month', 'options' =&gt; [ 'label' =&gt; 'Month', ], 'attributes' =&gt; [ 'min' =&gt; '2012-12', 'max' =&gt; '2020-01', 'step' =&gt; '1', // months; default step interval is 1 month ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The following methods are specific to the Month element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim , and will add the appropriate validators based on the values from the min , max , and step attributes. See the DateTime element documentation for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of months (default is 1 month).","title":"month"},{"location":"element/month/#month","text":"Laminas\\Form\\Element\\Month is meant to be paired with the FormMonth helper for HTML5 inputs with type \"month\" . This element adds filters and validators to its input filter specification in order to validate HTML5 month input values on the server.","title":"Month"},{"location":"element/month/#basic-usage","text":"This element automatically adds a type attribute of value month . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $month = new Element\\Month('month'); $month-&gt;setLabel('Month'); $month-&gt;setAttributes([ 'min' =&gt; '2012-01', 'max' =&gt; '2020-01', 'step' =&gt; '1', // months; default step interval is 1 month ]); $form = new Form('my-form'); $form-&gt;add($month); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Month::class, 'name' =&gt; 'month', 'options' =&gt; [ 'label' =&gt; 'Month', ], 'attributes' =&gt; [ 'min' =&gt; '2012-12', 'max' =&gt; '2020-01', 'step' =&gt; '1', // months; default step interval is 1 month ], ]);","title":"Basic Usage"},{"location":"element/month/#public-methods","text":"The following methods are specific to the Month element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim , and will add the appropriate validators based on the values from the min , max , and step attributes. See the DateTime element documentation for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of months (default is 1 month).","title":"Public Methods"},{"location":"element/multi-checkbox/","text":"MultiCheckbox Laminas\\Form\\Element\\MultiCheckbox is meant to be paired with the FormMultiCheckbox for HTML inputs with type \"checkbox\". This element adds an InArray validator to its input filter specification in order to validate on the server if the checkbox contains values from the multiple checkboxes. Basic Usage This element automatically adds a type attribute of value checkbox for every checkboxes. use Laminas\\Form\\Element; use Laminas\\Form\\Form; $multiCheckbox = new Element\\MultiCheckbox('multi-checkbox'); $multiCheckbox-&gt;setLabel('What do you like ?'); $multiCheckbox-&gt;setValueOptions([ '0' =&gt; 'Apple', '1' =&gt; 'Orange', '2' =&gt; 'Lemon' ]); $form = new Form('my-form'); $form-&gt;add($multiCheckbox); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\MultiCheckbox::class, 'name' =&gt; 'multi-checkbox', 'options' =&gt; [ 'label' =&gt; 'What do you like ?', 'value_options' =&gt; [ '0' =&gt; 'Apple', '1' =&gt; 'Orange', '2' =&gt; 'Lemon', ], ], ]); Advanced Usage In order to set attributes or customize the option elements, an array can be used instead of a string. The following keys are supported: label : The string displayed for the option. value : The form value associated with the option. selected : Boolean that sets whether the option is marked as selected. disabled : Boolean that sets whether the option will be disabled attributes : Array of HTML attributes that will be set on this option. Merged with the attributes set on the element. label_attributes : Array of HTML attributes that will be set on the label. Merged with the attributes set on the element's label. $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\MultiCheckbox::class, 'name' =&gt; 'multi-checkbox', 'options' =&gt; [ 'label' =&gt; 'What do you like ?', 'value_options' =&gt; [ [ 'value' =&gt; '0', 'label' =&gt; 'Apple', 'selected' =&gt; false, 'disabled' =&gt; false, 'attributes' =&gt; [ 'id' =&gt; 'apple_option', 'data-fruit' =&gt; 'apple', ], 'label_attributes' =&gt; [ 'id' =&gt; 'apple_label', ], ], [ 'value' =&gt; '1', 'label' =&gt; 'Orange', 'selected' =&gt; true, ], [ 'value' =&gt; '2', 'label' =&gt; 'Lemon', ], ], ], ]); Public Methods The following methods are specific to the MultiCheckbox element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element of type Checkbox. In addition to the options inherited from Checkbox allows value_options , which calls setValueOptions() . setValueOptions(array $options) : void Set the value options for every checkbox of the multi-checkbox. The array must contain a key/value pair for every checkbox. getValueOptions() : array Return the value options. unsetValueOption($key) : void Unset the value option from the multi-checkbox.","title":"MultiCheckbox"},{"location":"element/multi-checkbox/#multicheckbox","text":"Laminas\\Form\\Element\\MultiCheckbox is meant to be paired with the FormMultiCheckbox for HTML inputs with type \"checkbox\". This element adds an InArray validator to its input filter specification in order to validate on the server if the checkbox contains values from the multiple checkboxes.","title":"MultiCheckbox"},{"location":"element/multi-checkbox/#basic-usage","text":"This element automatically adds a type attribute of value checkbox for every checkboxes. use Laminas\\Form\\Element; use Laminas\\Form\\Form; $multiCheckbox = new Element\\MultiCheckbox('multi-checkbox'); $multiCheckbox-&gt;setLabel('What do you like ?'); $multiCheckbox-&gt;setValueOptions([ '0' =&gt; 'Apple', '1' =&gt; 'Orange', '2' =&gt; 'Lemon' ]); $form = new Form('my-form'); $form-&gt;add($multiCheckbox); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\MultiCheckbox::class, 'name' =&gt; 'multi-checkbox', 'options' =&gt; [ 'label' =&gt; 'What do you like ?', 'value_options' =&gt; [ '0' =&gt; 'Apple', '1' =&gt; 'Orange', '2' =&gt; 'Lemon', ], ], ]);","title":"Basic Usage"},{"location":"element/multi-checkbox/#advanced-usage","text":"In order to set attributes or customize the option elements, an array can be used instead of a string. The following keys are supported: label : The string displayed for the option. value : The form value associated with the option. selected : Boolean that sets whether the option is marked as selected. disabled : Boolean that sets whether the option will be disabled attributes : Array of HTML attributes that will be set on this option. Merged with the attributes set on the element. label_attributes : Array of HTML attributes that will be set on the label. Merged with the attributes set on the element's label. $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\MultiCheckbox::class, 'name' =&gt; 'multi-checkbox', 'options' =&gt; [ 'label' =&gt; 'What do you like ?', 'value_options' =&gt; [ [ 'value' =&gt; '0', 'label' =&gt; 'Apple', 'selected' =&gt; false, 'disabled' =&gt; false, 'attributes' =&gt; [ 'id' =&gt; 'apple_option', 'data-fruit' =&gt; 'apple', ], 'label_attributes' =&gt; [ 'id' =&gt; 'apple_label', ], ], [ 'value' =&gt; '1', 'label' =&gt; 'Orange', 'selected' =&gt; true, ], [ 'value' =&gt; '2', 'label' =&gt; 'Lemon', ], ], ], ]);","title":"Advanced Usage"},{"location":"element/multi-checkbox/#public-methods","text":"The following methods are specific to the MultiCheckbox element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element of type Checkbox. In addition to the options inherited from Checkbox allows value_options , which calls setValueOptions() . setValueOptions(array $options) : void Set the value options for every checkbox of the multi-checkbox. The array must contain a key/value pair for every checkbox. getValueOptions() : array Return the value options. unsetValueOption($key) : void Unset the value option from the multi-checkbox.","title":"Public Methods"},{"location":"element/number/","text":"Number Laminas\\Form\\Element\\Number is meant to be paired with the FormNumber helper for HTML5 inputs with type \"number\" . This element adds filters and validators to its input filter specification in order to validate HTML5 number input values on the server. Basic Usage This element automatically adds a type attribute of value number . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $number = new Element\\Number('quantity'); $number-&gt;setLabel('Quantity'); $number-&gt;setAttributes([ 'min' =&gt; '0', 'max' =&gt; '10', 'step' =&gt; '1', // default step interval is 1 ]); $form = new Form('my-form'); $form-&gt;add($number); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Number::class, 'name' =&gt; 'quantity', 'options' =&gt; [ 'label' =&gt; 'Quantity', ], 'attributes' =&gt; [ 'min' =&gt; '0', 'max' =&gt; '10', 'step' =&gt; '1', // default step interval is 1 ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The following methods are specific to the Number element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes. See below for specifics. getInputSpecification() will behave as follows based on the attributes provided: If the min attribute is set, a Laminas\\Validator\\GreaterThan validator will be added to ensure the number value is greater than the minimum value. The min value should be a valid floating point number . If the max attribute is set, a Laminas\\Validator\\LessThan validator will be added to ensure the number value is less than the maximum value. The max value should be a valid floating point number . If the step attribute is set to \"any\", step validations will be skipped. Otherwise, a Laminas\\Validator\\Step validator will be added to ensure the number value is within a certain interval (default is 1). The step value should be either \"any\" or a valid floating point number .","title":"number"},{"location":"element/number/#number","text":"Laminas\\Form\\Element\\Number is meant to be paired with the FormNumber helper for HTML5 inputs with type \"number\" . This element adds filters and validators to its input filter specification in order to validate HTML5 number input values on the server.","title":"Number"},{"location":"element/number/#basic-usage","text":"This element automatically adds a type attribute of value number . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $number = new Element\\Number('quantity'); $number-&gt;setLabel('Quantity'); $number-&gt;setAttributes([ 'min' =&gt; '0', 'max' =&gt; '10', 'step' =&gt; '1', // default step interval is 1 ]); $form = new Form('my-form'); $form-&gt;add($number); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Number::class, 'name' =&gt; 'quantity', 'options' =&gt; [ 'label' =&gt; 'Quantity', ], 'attributes' =&gt; [ 'min' =&gt; '0', 'max' =&gt; '10', 'step' =&gt; '1', // default step interval is 1 ], ]);","title":"Basic Usage"},{"location":"element/number/#public-methods","text":"The following methods are specific to the Number element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes. See below for specifics. getInputSpecification() will behave as follows based on the attributes provided: If the min attribute is set, a Laminas\\Validator\\GreaterThan validator will be added to ensure the number value is greater than the minimum value. The min value should be a valid floating point number . If the max attribute is set, a Laminas\\Validator\\LessThan validator will be added to ensure the number value is less than the maximum value. The max value should be a valid floating point number . If the step attribute is set to \"any\", step validations will be skipped. Otherwise, a Laminas\\Validator\\Step validator will be added to ensure the number value is within a certain interval (default is 1). The step value should be either \"any\" or a valid floating point number .","title":"Public Methods"},{"location":"element/password/","text":"Password Laminas\\Form\\Element\\Password represents a password form input. It can be used with the FormPassword view helper. Basic Usage This element automatically adds a type attribute of value password . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $password = new Element\\Password('my-password'); $password-&gt;setLabel('Enter your password'); $form = new Form('my-form'); $form-&gt;add($password);","title":"password"},{"location":"element/password/#password","text":"Laminas\\Form\\Element\\Password represents a password form input. It can be used with the FormPassword view helper.","title":"Password"},{"location":"element/password/#basic-usage","text":"This element automatically adds a type attribute of value password . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $password = new Element\\Password('my-password'); $password-&gt;setLabel('Enter your password'); $form = new Form('my-form'); $form-&gt;add($password);","title":"Basic Usage"},{"location":"element/radio/","text":"Radio Laminas\\Form\\Element\\Radio is meant to be paired with the FormRadio helper for HTML inputs with type \"radio\". This element adds an InArray validator to its input filter specification in order to validate on the server if the value is contains within the radio value elements. Basic Usage This element automatically adds a type attribute of value radio for every radio. use Laminas\\Form\\Element; use Laminas\\Form\\Form; $radio = new Element\\Radio('likes_chocolate'); $radio-&gt;setLabel('Do you like chocolate?'); $radio-&gt;setValueOptions([ '0' =&gt; 'No', '1' =&gt; 'Yes', ]); $form = new Form('my-form'); $form-&gt;add($radio); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Radio::class, 'name' =&gt; 'likes_chocolate', 'options' =&gt; [ 'label' =&gt; 'Do you like chocolate?', 'value_options' =&gt; [ '0' =&gt; 'No', '1' =&gt; 'Yes', ], ], ]); Advanced Usage See MultiCheckbox for examples of how to apply attributes and options to each radio button. Public Methods The Radio element extends the MultiCheckbox element, and inherits its methods .","title":"radio"},{"location":"element/radio/#radio","text":"Laminas\\Form\\Element\\Radio is meant to be paired with the FormRadio helper for HTML inputs with type \"radio\". This element adds an InArray validator to its input filter specification in order to validate on the server if the value is contains within the radio value elements.","title":"Radio"},{"location":"element/radio/#basic-usage","text":"This element automatically adds a type attribute of value radio for every radio. use Laminas\\Form\\Element; use Laminas\\Form\\Form; $radio = new Element\\Radio('likes_chocolate'); $radio-&gt;setLabel('Do you like chocolate?'); $radio-&gt;setValueOptions([ '0' =&gt; 'No', '1' =&gt; 'Yes', ]); $form = new Form('my-form'); $form-&gt;add($radio); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Radio::class, 'name' =&gt; 'likes_chocolate', 'options' =&gt; [ 'label' =&gt; 'Do you like chocolate?', 'value_options' =&gt; [ '0' =&gt; 'No', '1' =&gt; 'Yes', ], ], ]);","title":"Basic Usage"},{"location":"element/radio/#advanced-usage","text":"See MultiCheckbox for examples of how to apply attributes and options to each radio button.","title":"Advanced Usage"},{"location":"element/radio/#public-methods","text":"The Radio element extends the MultiCheckbox element, and inherits its methods .","title":"Public Methods"},{"location":"element/range/","text":"Range Laminas\\Form\\Element\\Range is meant to be paired with the FormRange helper for HTML5 inputs with type \"range\" . This element adds filters and validators to its input filter specification in order to validate HTML5 range values on the server. Basic Usage This element automatically adds a type attribute of value range . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $range = new Element\\Range('range'); $range-&gt;setLabel('Minimum and Maximum Amount'); $range-&gt;setAttributes([ 'min' =&gt; '0', // default minimum is 0 'max' =&gt; '100', // default maximum is 100 'step' =&gt; '1', // default interval is 1 ]); $form = new Form('my-form'); $form-&gt;add($range); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Range::class, 'name' =&gt; 'range', 'options' =&gt; [ 'label' =&gt; 'Minimum and Maximum Amount', ], 'attributes' =&gt; [ 'min' =&gt; 0, // default minimum is 0 'max' =&gt; 100, // default maximum is 100 'step' =&gt; 1, // default interval is 1 ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The Range element extends the Number element, and inherits its methods , with the following changes: Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes. See the Number element for more information. The Range element differs from Laminas\\Form\\Element\\Number in that the Laminas\\Validator\\GreaterThan and Laminas\\Validator\\LessThan validators will always be present. The default minimum is 1, and the default maximum is 100.","title":"range"},{"location":"element/range/#range","text":"Laminas\\Form\\Element\\Range is meant to be paired with the FormRange helper for HTML5 inputs with type \"range\" . This element adds filters and validators to its input filter specification in order to validate HTML5 range values on the server.","title":"Range"},{"location":"element/range/#basic-usage","text":"This element automatically adds a type attribute of value range . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $range = new Element\\Range('range'); $range-&gt;setLabel('Minimum and Maximum Amount'); $range-&gt;setAttributes([ 'min' =&gt; '0', // default minimum is 0 'max' =&gt; '100', // default maximum is 100 'step' =&gt; '1', // default interval is 1 ]); $form = new Form('my-form'); $form-&gt;add($range); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Range::class, 'name' =&gt; 'range', 'options' =&gt; [ 'label' =&gt; 'Minimum and Maximum Amount', ], 'attributes' =&gt; [ 'min' =&gt; 0, // default minimum is 0 'max' =&gt; 100, // default maximum is 100 'step' =&gt; 1, // default interval is 1 ], ]);","title":"Basic Usage"},{"location":"element/range/#public-methods","text":"The Range element extends the Number element, and inherits its methods , with the following changes: Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes. See the Number element for more information. The Range element differs from Laminas\\Form\\Element\\Number in that the Laminas\\Validator\\GreaterThan and Laminas\\Validator\\LessThan validators will always be present. The default minimum is 1, and the default maximum is 100.","title":"Public Methods"},{"location":"element/search/","text":"Search Laminas\\Form\\Element\\Search is meant to be paired with the FormSearch helper for HTML5 inputs with type \"search\" Available since 2.9.0. Basic Usage This element automatically adds a type attribute of value search . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $search = new Element\\Search('search'); $search-&gt;setLabel('Search'); $form = new Form('my-form'); $form-&gt;add($search); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Search::class, 'name' =&gt; 'search', 'options' =&gt; [ 'label' =&gt; 'Search', ], ]); Public Methods This element defines no methods beyond those of the parent Element class.","title":"search"},{"location":"element/search/#search","text":"Laminas\\Form\\Element\\Search is meant to be paired with the FormSearch helper for HTML5 inputs with type \"search\" Available since 2.9.0.","title":"Search"},{"location":"element/search/#basic-usage","text":"This element automatically adds a type attribute of value search . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $search = new Element\\Search('search'); $search-&gt;setLabel('Search'); $form = new Form('my-form'); $form-&gt;add($search); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Search::class, 'name' =&gt; 'search', 'options' =&gt; [ 'label' =&gt; 'Search', ], ]);","title":"Basic Usage"},{"location":"element/search/#public-methods","text":"This element defines no methods beyond those of the parent Element class.","title":"Public Methods"},{"location":"element/select/","text":"Select Laminas\\Form\\Element\\Select is meant to be paired with FormSelect for HTML inputs with type \"select\". This element adds an InArray validator to its input filter specification in order to validate on the server if the selected value belongs to the values. This element can be used as a multi-select element by adding the multiple HTML attribute to the element. Basic Usage This element automatically adds a type attribute of value select . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $select = new Element\\Select('language'); $select-&gt;setLabel('Which is your mother tongue?'); $select-&gt;setValueOptions([ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ]); $form = new Form('language'); $form-&gt;add($select); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Select::class, 'name' =&gt; 'language', 'options' =&gt; [ 'label' =&gt; 'Which is your mother tongue?', 'value_options' =&gt; [ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ], ], ]); You can add an empty option (option with no value) using the empty_option option: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Select::class, 'name' =&gt; 'language', 'options' =&gt; [ 'label' =&gt; 'Which is your mother tongue?', 'empty_option' =&gt; 'Please choose your language', 'value_options' =&gt; [ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ], ], ]); Option groups are also supported by adding an options key to the value options: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $select = new Element\\Select('language'); $select-&gt;setLabel('Which is your mother tongue?'); $select-&gt;setValueOptions([ 'european' =&gt; [ 'label' =&gt; 'European languages', 'options' =&gt; [ '0' =&gt; 'French', '1' =&gt; 'Italian', ], ], 'asian' =&gt; [ 'label' =&gt; 'Asian languages', 'options' =&gt; [ '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ], ], ]); $form = new Form('language'); $form-&gt;add($select); Attributes on the options are supported by providing the options as a specification array instead of key-value pairs: $select-&gt;setValueOptions([ [ 'value' =&gt; '0', 'label' =&gt; 'French', 'attributes' =&gt; [ 'data-locale' = 'fr' ], ], [ 'value' =&gt; '1', 'label' =&gt; 'Italian', 'disabled' =&gt; true, ], ]); Public Methods The following methods are specific to the Select element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element. Accepted options, in addition to the inherited options, include value_options , empty_option , and disable_inarray_validator , which call setValueOptions() , setEmptyOption() and setDisableInArrayValidator() , respectively. setValueOptions(array $options) : void Set the value options for the select element. The array must contain key/value pairs. getValueOptions() : array Return the value options. unsetValueOption($key) : void Unset the value option from the select element. setEmptyOption($emptyOption) : void Optionally set a label for an empty option (option with no value). It is set to null by default, which means that no empty option will be rendered. getEmptyOption() : string|null Get the label for the empty option ( null if none).","title":"select"},{"location":"element/select/#select","text":"Laminas\\Form\\Element\\Select is meant to be paired with FormSelect for HTML inputs with type \"select\". This element adds an InArray validator to its input filter specification in order to validate on the server if the selected value belongs to the values. This element can be used as a multi-select element by adding the multiple HTML attribute to the element.","title":"Select"},{"location":"element/select/#basic-usage","text":"This element automatically adds a type attribute of value select . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $select = new Element\\Select('language'); $select-&gt;setLabel('Which is your mother tongue?'); $select-&gt;setValueOptions([ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ]); $form = new Form('language'); $form-&gt;add($select); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Select::class, 'name' =&gt; 'language', 'options' =&gt; [ 'label' =&gt; 'Which is your mother tongue?', 'value_options' =&gt; [ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ], ], ]); You can add an empty option (option with no value) using the empty_option option: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Select::class, 'name' =&gt; 'language', 'options' =&gt; [ 'label' =&gt; 'Which is your mother tongue?', 'empty_option' =&gt; 'Please choose your language', 'value_options' =&gt; [ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ], ], ]); Option groups are also supported by adding an options key to the value options: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $select = new Element\\Select('language'); $select-&gt;setLabel('Which is your mother tongue?'); $select-&gt;setValueOptions([ 'european' =&gt; [ 'label' =&gt; 'European languages', 'options' =&gt; [ '0' =&gt; 'French', '1' =&gt; 'Italian', ], ], 'asian' =&gt; [ 'label' =&gt; 'Asian languages', 'options' =&gt; [ '2' =&gt; 'Japanese', '3' =&gt; 'Chinese', ], ], ]); $form = new Form('language'); $form-&gt;add($select); Attributes on the options are supported by providing the options as a specification array instead of key-value pairs: $select-&gt;setValueOptions([ [ 'value' =&gt; '0', 'label' =&gt; 'French', 'attributes' =&gt; [ 'data-locale' = 'fr' ], ], [ 'value' =&gt; '1', 'label' =&gt; 'Italian', 'disabled' =&gt; true, ], ]);","title":"Basic Usage"},{"location":"element/select/#public-methods","text":"The following methods are specific to the Select element; all other methods defined by the parent Element class are also available. Method signature Description setOptions(array $options) : void Set options for an element. Accepted options, in addition to the inherited options, include value_options , empty_option , and disable_inarray_validator , which call setValueOptions() , setEmptyOption() and setDisableInArrayValidator() , respectively. setValueOptions(array $options) : void Set the value options for the select element. The array must contain key/value pairs. getValueOptions() : array Return the value options. unsetValueOption($key) : void Unset the value option from the select element. setEmptyOption($emptyOption) : void Optionally set a label for an empty option (option with no value). It is set to null by default, which means that no empty option will be rendered. getEmptyOption() : string|null Get the label for the empty option ( null if none).","title":"Public Methods"},{"location":"element/submit/","text":"Submit Laminas\\Form\\Element\\Submit represents a submit button form input. It should be used with the FormSubmit view helper. Basic Usage This element automatically adds a type attribute of value submit . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $submit = new Element\\Submit('my-submit'); $submit-&gt;setValue('Submit Form'); $form = new Form('my-form'); $form-&gt;add($submit);","title":"submit"},{"location":"element/submit/#submit","text":"Laminas\\Form\\Element\\Submit represents a submit button form input. It should be used with the FormSubmit view helper.","title":"Submit"},{"location":"element/submit/#basic-usage","text":"This element automatically adds a type attribute of value submit . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $submit = new Element\\Submit('my-submit'); $submit-&gt;setValue('Submit Form'); $form = new Form('my-form'); $form-&gt;add($submit);","title":"Basic Usage"},{"location":"element/tel/","text":"Tel Laminas\\Form\\Element\\Tel is meant to be paired with the FormTel helper for HTML5 inputs with type \"tel\" . This element adds filters and validators to its input filter specification in order to validate HTML5 tel input values on the server. Available since 2.9.0. Basic Usage This element automatically adds a type attribute of value tel . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $phone = new Element\\Tel('phone'); $phone-&gt;setLabel('Phone'); $form = new Form('my-form'); $form-&gt;add($phone); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Tel::class, 'name' =&gt; 'phone', 'options' =&gt; [ 'label' =&gt; 'Phone', ], ]); Public Methods The following methods are specific to the Tel element: Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and Laminas\\Filter\\StripNewlines , as well as a regex validator to ensure the value does not contain any carriage returns or newlines within it.","title":"tel"},{"location":"element/tel/#tel","text":"Laminas\\Form\\Element\\Tel is meant to be paired with the FormTel helper for HTML5 inputs with type \"tel\" . This element adds filters and validators to its input filter specification in order to validate HTML5 tel input values on the server. Available since 2.9.0.","title":"Tel"},{"location":"element/tel/#basic-usage","text":"This element automatically adds a type attribute of value tel . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $phone = new Element\\Tel('phone'); $phone-&gt;setLabel('Phone'); $form = new Form('my-form'); $form-&gt;add($phone); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Tel::class, 'name' =&gt; 'phone', 'options' =&gt; [ 'label' =&gt; 'Phone', ], ]);","title":"Basic Usage"},{"location":"element/tel/#public-methods","text":"The following methods are specific to the Tel element: Method signature Description getInputSpecification() : array Returns an input filter specification, which includes Laminas\\Filter\\StringTrim and Laminas\\Filter\\StripNewlines , as well as a regex validator to ensure the value does not contain any carriage returns or newlines within it.","title":"Public Methods"},{"location":"element/text/","text":"Text Laminas\\Form\\Element\\Text represents a text form input. It should be used with the FormText view helper. Basic Usage This element automatically adds a type attribute of value text . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $text = new Element\\Text('my-text'); $text-&gt;setLabel('Enter your name'); $form = new Form('my-form'); $form-&gt;add($text);","title":"text"},{"location":"element/text/#text","text":"Laminas\\Form\\Element\\Text represents a text form input. It should be used with the FormText view helper.","title":"Text"},{"location":"element/text/#basic-usage","text":"This element automatically adds a type attribute of value text . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $text = new Element\\Text('my-text'); $text-&gt;setLabel('Enter your name'); $form = new Form('my-form'); $form-&gt;add($text);","title":"Basic Usage"},{"location":"element/textarea/","text":"Textarea Laminas\\Form\\Element\\Textarea represents a textarea form input. It should be used with the FormTextarea view helper. Basic Usage This element automatically adds a type attribute of value textarea . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $textarea = new Element\\Textarea('my-textarea'); $textarea-&gt;setLabel('Enter a description'); $form = new Form('my-form'); $form-&gt;add($textarea);","title":"textarea"},{"location":"element/textarea/#textarea","text":"Laminas\\Form\\Element\\Textarea represents a textarea form input. It should be used with the FormTextarea view helper.","title":"Textarea"},{"location":"element/textarea/#basic-usage","text":"This element automatically adds a type attribute of value textarea . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $textarea = new Element\\Textarea('my-textarea'); $textarea-&gt;setLabel('Enter a description'); $form = new Form('my-form'); $form-&gt;add($textarea);","title":"Basic Usage"},{"location":"element/time/","text":"Time Laminas\\Form\\Element\\Time is meant to be paired with the FormTime helper for HTML5 inputs with type \"time\" . This element adds filters and validators to its input filter specification in order to validate HTML5 time input values on the server. Basic Usage This element automatically adds a type attribute of value time . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $time = new Element\\Time('time'); $time-&gt;setLabel('Time'); $time-&gt;setAttributes([ 'min' =&gt; '00:00:00', 'max' =&gt; '23:59:59', 'step' =&gt; '60', // seconds; default step interval is 60 seconds ]); $time-&gt;setOptions([ 'format' =&gt; 'H:i:s', ]); $form = new Form('my-form'); $form-&gt;add($time); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Time::class, 'name' =&gt; 'time', 'options'=&gt; [ 'label' =&gt; 'Time', 'format' =&gt; 'H:i:s', ], 'attributes' =&gt; [ 'min' =&gt; '00:00:00', 'max' =&gt; '23:59:59', 'step' =&gt; '60', // seconds; default step interval is 60 seconds ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Default date format The default date format for the validator is H:i:s . However, a valid time string is not required to have a \"seconds\" representation. In fact, some user agent UIs such as Google Chrome and Opera submit time elements using the H:i format (i.e. without a seconds representation). Set the date format accordingly. Public Methods The following methods are specific to the Time element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime element for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of seconds (default is 60 seconds).","title":"time"},{"location":"element/time/#time","text":"Laminas\\Form\\Element\\Time is meant to be paired with the FormTime helper for HTML5 inputs with type \"time\" . This element adds filters and validators to its input filter specification in order to validate HTML5 time input values on the server.","title":"Time"},{"location":"element/time/#basic-usage","text":"This element automatically adds a type attribute of value time . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $time = new Element\\Time('time'); $time-&gt;setLabel('Time'); $time-&gt;setAttributes([ 'min' =&gt; '00:00:00', 'max' =&gt; '23:59:59', 'step' =&gt; '60', // seconds; default step interval is 60 seconds ]); $time-&gt;setOptions([ 'format' =&gt; 'H:i:s', ]); $form = new Form('my-form'); $form-&gt;add($time); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Time::class, 'name' =&gt; 'time', 'options'=&gt; [ 'label' =&gt; 'Time', 'format' =&gt; 'H:i:s', ], 'attributes' =&gt; [ 'min' =&gt; '00:00:00', 'max' =&gt; '23:59:59', 'step' =&gt; '60', // seconds; default step interval is 60 seconds ], ]);","title":"Basic Usage"},{"location":"element/time/#public-methods","text":"The following methods are specific to the Time element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime element for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of seconds (default is 60 seconds).","title":"Public Methods"},{"location":"element/url/","text":"Url Laminas\\Form\\Element\\Url is meant to be paired with the FormUrl helper for HTML5 inputs with type \"url\" . This element adds filters and a Laminas\\Validator\\Uri validator to its input filter specification for validating HTML5 URL input values on the server. Basic Usage This element automatically adds a type attribute of value url . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $url = new Element\\Url('webpage-url'); $url-&gt;setLabel('Webpage URL'); $form = new Form('my-form'); $form-&gt;add($url); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Url::class, 'name' =&gt; 'webpage-url', 'options' =&gt; [ 'label' =&gt; 'Webpage URL', ], ]); Public Methods The following methods are specific to the Url element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes a Laminas\\Filter\\StringTrim filter, and a Laminas\\Validator\\Uri to validate the URI string.","title":"url"},{"location":"element/url/#url","text":"Laminas\\Form\\Element\\Url is meant to be paired with the FormUrl helper for HTML5 inputs with type \"url\" . This element adds filters and a Laminas\\Validator\\Uri validator to its input filter specification for validating HTML5 URL input values on the server.","title":"Url"},{"location":"element/url/#basic-usage","text":"This element automatically adds a type attribute of value url . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $url = new Element\\Url('webpage-url'); $url-&gt;setLabel('Webpage URL'); $form = new Form('my-form'); $form-&gt;add($url); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Url::class, 'name' =&gt; 'webpage-url', 'options' =&gt; [ 'label' =&gt; 'Webpage URL', ], ]);","title":"Basic Usage"},{"location":"element/url/#public-methods","text":"The following methods are specific to the Url element; all other methods defined by the parent Element class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes a Laminas\\Filter\\StringTrim filter, and a Laminas\\Validator\\Uri to validate the URI string.","title":"Public Methods"},{"location":"element/week/","text":"Week Laminas\\Form\\Element\\Week is meant to be paired with the FormWeek helper for HTML5 inputs with type \"week\" . This element adds filters and validators to its input filter specification in order to validate HTML5 week input values on the server. Basic Usage This element automatically adds a type attribute of value week . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $week = new Element\\Week('week'); $week-&gt;setLabel('Week'); $week-&gt;setAttributes([ 'min' =&gt; '2012-W01', 'max' =&gt; '2020-W01', 'step' =&gt; '1', // weeks; default step interval is 1 week ]); $form = new Form('my-form'); $form-&gt;add($week); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Week::class, 'name' =&gt; 'week', 'options' =&gt; [ 'label' =&gt; 'Week', ], 'attributes' =&gt; [ 'min' =&gt; '2012-W01', 'max' =&gt; '2020-W01', 'step' =&gt; '1', // weeks; default step interval is 1 week ], ]); Set all attributes before calling prepare The min , max , and step attributes should be set prior to calling Laminas\\Form::prepare() . Otherwise, the default input specification for the element may not contain the correct validation rules. Public Methods The following methods are specific to the Week element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime element for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of weeks (default is 1 week).","title":"week"},{"location":"element/week/#week","text":"Laminas\\Form\\Element\\Week is meant to be paired with the FormWeek helper for HTML5 inputs with type \"week\" . This element adds filters and validators to its input filter specification in order to validate HTML5 week input values on the server.","title":"Week"},{"location":"element/week/#basic-usage","text":"This element automatically adds a type attribute of value week . use Laminas\\Form\\Element; use Laminas\\Form\\Form; $week = new Element\\Week('week'); $week-&gt;setLabel('Week'); $week-&gt;setAttributes([ 'min' =&gt; '2012-W01', 'max' =&gt; '2020-W01', 'step' =&gt; '1', // weeks; default step interval is 1 week ]); $form = new Form('my-form'); $form-&gt;add($week); Using array notation: use Laminas\\Form\\Element; use Laminas\\Form\\Form; $form = new Form('my-form'); $form-&gt;add([ 'type' =&gt; Element\\Week::class, 'name' =&gt; 'week', 'options' =&gt; [ 'label' =&gt; 'Week', ], 'attributes' =&gt; [ 'min' =&gt; '2012-W01', 'max' =&gt; '2020-W01', 'step' =&gt; '1', // weeks; default step interval is 1 week ], ]);","title":"Basic Usage"},{"location":"element/week/#public-methods","text":"The following methods are specific to the Week element; all other methods inherited from the parent DateTime class are also available. Method signature Description getInputSpecification() : array Returns a input filter specification, which includes Laminas\\Filter\\StringTrim and will add the appropriate validators based on the values from the min , max , and step attributes and format option. See the DateTime element for more information. One difference from Laminas\\Form\\Element\\DateTime is that the Laminas\\Validator\\DateStep validator will expect the step attribute to use an interval of weeks (default is 1 week).","title":"Public Methods"},{"location":"helper/abstract-helper/","text":"AbstractHelper The AbstractHelper is used as a base abstract class for laminas-form view helpers, providing methods for validating form HTML attributes, as well as controlling the doctype and character encoding. AbstractHelper also extends from Laminas\\I18n\\View\\Helper\\AbstractTranslatorHelper which provides an implementation for the Laminas\\I18n\\Translator\\TranslatorAwareInterface that allows setting a translator and text domain. Public methods The following public methods are in addition to the inherited methods of Laminas\\I18n\\View\\Helper\\AbstractTranslatorHelper . Method signature Description setDoctype(string $doctype) : void Sets a doctype to use in the helper. getDoctype() : string Returns the doctype used in the helper. setEncoding(string $encoding) : void Set the translation text domain to use in helper when translating. getEncoding() : string Returns the character encoding used in the helper. getId() : string or null Returns the element id. If no ID attribute present, attempts to use the name attribute. If name attribute is also not present, returns null . addTranslatableAttribute(string $attribute) : self Marks the given HTML attribute as translatable. addTranslatableAttributePrefix(string $prefix) : self Marks all HTML attributes that start with the given prefix as translatable. addTranslatableAttribute(string $attribute) : self Marks the given HTML attribute as translatable. addTranslatableAttributePrefix(string $prefix) : self Marks all HTML attributes that start with the given prefix as translatable. addDefaultTranslatableAttribute(string $attribute) : void Marks the given HTML attribute as translatable for all view helpers. addDefaultTranslatableAttributePrefix(string $prefix) : void Marks all HTML attributes that start with the given prefix as translatable for all view helpers. addValidAttribute(string $attribute) : self Add an HTML attribute to the list of valid attributes for the given element. addValidAttributePrefix(string $prefix) : self Add an HTML attribute prefix to the list of valid attribute prefixes. Any attribute with this preix will be considered valid. By default, the list includes \"data-\", \"aria-\", and \"x-\". Translation Attaching a translator and setting a text domain (using the formLabel view helper as an example): // Setting a translator $this-&gt;formLabel()-&gt;setTranslator($translator); // Setting a text domain $this-&gt;formLabel()-&gt;setTranslatorTextDomain('my-text-domain'); // Setting both $this-&gt;formLabel()-&gt;setTranslator($translator, 'my-text-domain'); Enabling translation If you have a translator in your application container under either the key, translator or MvcTranslator , the view helper plugin manager will automatically attach the translator to the view helpers. What will be translated? The specific view helpers are responsible to determine what exactly should be translated (e. g. the Label in the FormLabel view helper or the \"title\" HTML attribute). If you want to have certain HTML attribute values translated you can mark them as \"translatable\": // mark one attribute as translatable $this-&gt;formLabel()-&gt;addTranslatableAttribute('data-translate-me'); // mark an prefix as translatable $this-&gt;formLabel()-&gt;addTranslatableAttributePrefix('data-translatable-'); Or you can mark them as translatable for all view helpers (e. g. the title attribute): // mark one attribute as translatable \\Laminas\\Form\\View\\Helper\\AbstractHelper-&gt;addDefaultTranslatableAttribute('title'); // mark an prefix as translatable \\Laminas\\Form\\View\\Helper\\AbstractHelper-&gt;addDefaultTranslatableAttributePrefix('data-translatable-'); Allowing framework-specific attributes Many JavaScript frameworks use custom attributes and/or attribute prefixes with elements, to facilitate various bindings and event listeners. Examples include ng- for Angular elements, and v- for Vue . laminas-form view helpers are strict about what attributes they consider valid. If you wish to allow additional attributes, you will need to notify the helper of them. The first mechanism is to add a specific attribute: $helper-&gt;addValidAttribute('some-attribute'); If you wish to allow a set of attributes with a common prefix, use the following: $helper-&gt;addValidAttributePrefix('ng-');","title":"AbstractHelper"},{"location":"helper/abstract-helper/#abstracthelper","text":"The AbstractHelper is used as a base abstract class for laminas-form view helpers, providing methods for validating form HTML attributes, as well as controlling the doctype and character encoding. AbstractHelper also extends from Laminas\\I18n\\View\\Helper\\AbstractTranslatorHelper which provides an implementation for the Laminas\\I18n\\Translator\\TranslatorAwareInterface that allows setting a translator and text domain.","title":"AbstractHelper"},{"location":"helper/abstract-helper/#public-methods","text":"The following public methods are in addition to the inherited methods of Laminas\\I18n\\View\\Helper\\AbstractTranslatorHelper . Method signature Description setDoctype(string $doctype) : void Sets a doctype to use in the helper. getDoctype() : string Returns the doctype used in the helper. setEncoding(string $encoding) : void Set the translation text domain to use in helper when translating. getEncoding() : string Returns the character encoding used in the helper. getId() : string or null Returns the element id. If no ID attribute present, attempts to use the name attribute. If name attribute is also not present, returns null . addTranslatableAttribute(string $attribute) : self Marks the given HTML attribute as translatable. addTranslatableAttributePrefix(string $prefix) : self Marks all HTML attributes that start with the given prefix as translatable. addTranslatableAttribute(string $attribute) : self Marks the given HTML attribute as translatable. addTranslatableAttributePrefix(string $prefix) : self Marks all HTML attributes that start with the given prefix as translatable. addDefaultTranslatableAttribute(string $attribute) : void Marks the given HTML attribute as translatable for all view helpers. addDefaultTranslatableAttributePrefix(string $prefix) : void Marks all HTML attributes that start with the given prefix as translatable for all view helpers. addValidAttribute(string $attribute) : self Add an HTML attribute to the list of valid attributes for the given element. addValidAttributePrefix(string $prefix) : self Add an HTML attribute prefix to the list of valid attribute prefixes. Any attribute with this preix will be considered valid. By default, the list includes \"data-\", \"aria-\", and \"x-\".","title":"Public methods"},{"location":"helper/abstract-helper/#translation","text":"Attaching a translator and setting a text domain (using the formLabel view helper as an example): // Setting a translator $this-&gt;formLabel()-&gt;setTranslator($translator); // Setting a text domain $this-&gt;formLabel()-&gt;setTranslatorTextDomain('my-text-domain'); // Setting both $this-&gt;formLabel()-&gt;setTranslator($translator, 'my-text-domain');","title":"Translation"},{"location":"helper/abstract-helper/#allowing-framework-specific-attributes","text":"Many JavaScript frameworks use custom attributes and/or attribute prefixes with elements, to facilitate various bindings and event listeners. Examples include ng- for Angular elements, and v- for Vue . laminas-form view helpers are strict about what attributes they consider valid. If you wish to allow additional attributes, you will need to notify the helper of them. The first mechanism is to add a specific attribute: $helper-&gt;addValidAttribute('some-attribute'); If you wish to allow a set of attributes with a common prefix, use the following: $helper-&gt;addValidAttributePrefix('ng-');","title":"Allowing framework-specific attributes"},{"location":"helper/form-button/","text":"FormButton The FormButton view helper is used to render a &lt;button&gt; HTML element and its attributes. Basic usage use Laminas\\Form\\Element; $element = new Element\\Button('my-button'); $element-&gt;setLabel('Reset'); // Within your view... /** * Example #1: Render entire button in one shot... */ echo $this-&gt;formButton($element); // Result: &lt;button name=\"my-button\" type=\"button\"&gt;Reset&lt;/button&gt; /** * Example #2: Render button in 3 steps */ // Render the opening tag echo $this-&gt;formButton()-&gt;openTag($element); // Result: &lt;button name=\"my-button\" type=\"button\"&gt; echo '&lt;span class=\"inner\"&gt;' . $element-&gt;getLabel() . '&lt;/span&gt;'; // Render the closing tag echo $this-&gt;formButton()-&gt;closeTag(); // Result: &lt;/button&gt; /** * Example #3: Override the element label */ echo $this-&gt;formButton()-&gt;render($element, 'My Content'); // Result: &lt;button name=\"my-button\" type=\"button\"&gt;My Content&lt;/button&gt; Public methods The following public methods are in addition to those inherited from the FormInput : Method signature Description openTag($element = null) : string Renders the &lt;button&gt; open tag for the $element instance. closeTag() : string Renders a &lt;/button&gt; closing tag. render(ElementInterface $element [, $buttonContent = null]) : string Renders a button's opening tag, inner content, and closing tag. If $buttonContent is null , defaults to $element 's label.","title":"formButton"},{"location":"helper/form-button/#formbutton","text":"The FormButton view helper is used to render a &lt;button&gt; HTML element and its attributes.","title":"FormButton"},{"location":"helper/form-button/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Button('my-button'); $element-&gt;setLabel('Reset'); // Within your view... /** * Example #1: Render entire button in one shot... */ echo $this-&gt;formButton($element); // Result: &lt;button name=\"my-button\" type=\"button\"&gt;Reset&lt;/button&gt; /** * Example #2: Render button in 3 steps */ // Render the opening tag echo $this-&gt;formButton()-&gt;openTag($element); // Result: &lt;button name=\"my-button\" type=\"button\"&gt; echo '&lt;span class=\"inner\"&gt;' . $element-&gt;getLabel() . '&lt;/span&gt;'; // Render the closing tag echo $this-&gt;formButton()-&gt;closeTag(); // Result: &lt;/button&gt; /** * Example #3: Override the element label */ echo $this-&gt;formButton()-&gt;render($element, 'My Content'); // Result: &lt;button name=\"my-button\" type=\"button\"&gt;My Content&lt;/button&gt;","title":"Basic usage"},{"location":"helper/form-button/#public-methods","text":"The following public methods are in addition to those inherited from the FormInput : Method signature Description openTag($element = null) : string Renders the &lt;button&gt; open tag for the $element instance. closeTag() : string Renders a &lt;/button&gt; closing tag. render(ElementInterface $element [, $buttonContent = null]) : string Renders a button's opening tag, inner content, and closing tag. If $buttonContent is null , defaults to $element 's label.","title":"Public methods"},{"location":"helper/form-captcha/","text":"FormCaptcha Laminas\\Form\\View\\Helper\\FormCaptcha will render a CAPTCHA as defined in a Captcha element. Basic usage use Laminas\\Captcha; use Laminas\\Form\\Element; $captcha = new Element\\Captcha('captcha'); $captcha-&gt;setCaptcha(new Captcha\\Dumb()); $captcha-&gt;setLabel('Please verify you are human'); // Within your view... echo $this-&gt;formCaptcha($captcha);","title":"formCaptcha"},{"location":"helper/form-captcha/#formcaptcha","text":"Laminas\\Form\\View\\Helper\\FormCaptcha will render a CAPTCHA as defined in a Captcha element.","title":"FormCaptcha"},{"location":"helper/form-captcha/#basic-usage","text":"use Laminas\\Captcha; use Laminas\\Form\\Element; $captcha = new Element\\Captcha('captcha'); $captcha-&gt;setCaptcha(new Captcha\\Dumb()); $captcha-&gt;setLabel('Please verify you are human'); // Within your view... echo $this-&gt;formCaptcha($captcha);","title":"Basic usage"},{"location":"helper/form-checkbox/","text":"FormCheckbox The FormCheckbox view helper can be used to render an &lt;input type=\"checkbox\"&gt; HTML form input. It is meant to work with the checkbox element , which provides a default input specification for validating the checkbox values. Basic usage use Laminas\\Form\\Element; $element = new Element\\Checkbox('my-checkbox'); // Within your view... /** * Example #1: Default options */ echo $this-&gt;formCheckbox($element); // Result: // &lt;input type=\"hidden\" name=\"my-checkbox\" value=\"0\"&gt; // &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"1\"&gt; /** * Example #2: Disable hidden element */ $element-&gt;setUseHiddenElement(false); echo $this-&gt;formCheckbox($element); // Result: &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"1\"&gt; /** * Example #3: Change checked/unchecked values */ $element-&gt;setUseHiddenElement(true); $element-&gt;setUncheckedValue('no'); $element-&gt;setCheckedValue('yes'); echo $this-&gt;formCheckbox($element); // Result: // &lt;input type=\"hidden\" name=\"my-checkbox\" value=\"no\"&gt; // &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"yes\"&gt;","title":"formCheckbox"},{"location":"helper/form-checkbox/#formcheckbox","text":"The FormCheckbox view helper can be used to render an &lt;input type=\"checkbox\"&gt; HTML form input. It is meant to work with the checkbox element , which provides a default input specification for validating the checkbox values.","title":"FormCheckbox"},{"location":"helper/form-checkbox/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Checkbox('my-checkbox'); // Within your view... /** * Example #1: Default options */ echo $this-&gt;formCheckbox($element); // Result: // &lt;input type=\"hidden\" name=\"my-checkbox\" value=\"0\"&gt; // &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"1\"&gt; /** * Example #2: Disable hidden element */ $element-&gt;setUseHiddenElement(false); echo $this-&gt;formCheckbox($element); // Result: &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"1\"&gt; /** * Example #3: Change checked/unchecked values */ $element-&gt;setUseHiddenElement(true); $element-&gt;setUncheckedValue('no'); $element-&gt;setCheckedValue('yes'); echo $this-&gt;formCheckbox($element); // Result: // &lt;input type=\"hidden\" name=\"my-checkbox\" value=\"no\"&gt; // &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"yes\"&gt;","title":"Basic usage"},{"location":"helper/form-collection/","text":"FormCollection Laminas\\Form\\View\\Helper\\FormCollection was originally developed for rendering Laminas\\Form\\Element\\Collection instances, but is capable of rendering any iterable element type, including fieldsets and forms. Internally, it iterates the element provided, and calls one of the following view helpers based on the element encountered: If a fieldset (or, by extension, collection or form) is encountered, it is passed to itself (in other words, FormCollection ). Otherwise, it is passed to FormRow . Basic usage use My\\ContactFieldset; use Laminas\\Form\\Element; $collection = new Element\\Collection(); $collection-&gt;setName('contacts'); $collection-&gt;setShouldCreateTemplate(true); $collection-&gt;setAllowAdd(true); $collection-&gt;setTargetElement([ 'type' =&gt; ContactFieldset::class ]); // In a view script: echo $this-&gt;formCollection($collection); The above, assuming the fieldset is created correctly, will generate one or more fieldsets with the name contacts[] , each containing the elements defined in My\\ContactFieldset . The number of fieldsets created will be based on what data was bound to the form. By default, the collection is wrapped into &lt;fieldset&gt; tag. You can override this behavior passing false as second parameter of the helper. You can also prevent fieldset addition using setShouldWrap() method. // In a view script // Both following lines are equivalent: echo $this-&gt;formCollection($collection, false); echo $this-&gt;formCollection($collection)-&gt;setShouldWrap(false);","title":"formCollection"},{"location":"helper/form-collection/#formcollection","text":"Laminas\\Form\\View\\Helper\\FormCollection was originally developed for rendering Laminas\\Form\\Element\\Collection instances, but is capable of rendering any iterable element type, including fieldsets and forms. Internally, it iterates the element provided, and calls one of the following view helpers based on the element encountered: If a fieldset (or, by extension, collection or form) is encountered, it is passed to itself (in other words, FormCollection ). Otherwise, it is passed to FormRow .","title":"FormCollection"},{"location":"helper/form-collection/#basic-usage","text":"use My\\ContactFieldset; use Laminas\\Form\\Element; $collection = new Element\\Collection(); $collection-&gt;setName('contacts'); $collection-&gt;setShouldCreateTemplate(true); $collection-&gt;setAllowAdd(true); $collection-&gt;setTargetElement([ 'type' =&gt; ContactFieldset::class ]); // In a view script: echo $this-&gt;formCollection($collection); The above, assuming the fieldset is created correctly, will generate one or more fieldsets with the name contacts[] , each containing the elements defined in My\\ContactFieldset . The number of fieldsets created will be based on what data was bound to the form. By default, the collection is wrapped into &lt;fieldset&gt; tag. You can override this behavior passing false as second parameter of the helper. You can also prevent fieldset addition using setShouldWrap() method. // In a view script // Both following lines are equivalent: echo $this-&gt;formCollection($collection, false); echo $this-&gt;formCollection($collection)-&gt;setShouldWrap(false);","title":"Basic usage"},{"location":"helper/form-color/","text":"FormColor The FormColor view helper can be used to render a &lt;input type=\"color\"&gt; HTML5 form input. It is meant to work with the color element . Basic usage use Laminas\\Form\\Element; $element = new Element\\Color('my-color'); // Within your view... echo $this-&gt;formColor($element); Output: &lt;input type=\"color\" name=\"my-color\" value=\"\"&gt;","title":"formColor"},{"location":"helper/form-color/#formcolor","text":"The FormColor view helper can be used to render a &lt;input type=\"color\"&gt; HTML5 form input. It is meant to work with the color element .","title":"FormColor"},{"location":"helper/form-color/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Color('my-color'); // Within your view... echo $this-&gt;formColor($element); Output: &lt;input type=\"color\" name=\"my-color\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-date-time-local/","text":"FormDateTimeLocal The FormDateTimeLocal view helper can be used to render a &lt;input type=\"datetime-local\"&gt; HTML5 form input. It is meant to work with the DateTimeLocal element , which provides a default input specification for validating HTML5 datetime values. FormDateTimeLocal extends from FormDateTime . Basic usage use Laminas\\Form\\Element; $element = new Element\\DateTimeLocal('my-datetime'); // Within your view... echo $this-&gt;formDateTimeLocal($element); // Result: &lt;input type=\"datetime-local\" name=\"my-datetime\" value=\"\"&gt;","title":"formDateTimeLocal"},{"location":"helper/form-date-time-local/#formdatetimelocal","text":"The FormDateTimeLocal view helper can be used to render a &lt;input type=\"datetime-local\"&gt; HTML5 form input. It is meant to work with the DateTimeLocal element , which provides a default input specification for validating HTML5 datetime values. FormDateTimeLocal extends from FormDateTime .","title":"FormDateTimeLocal"},{"location":"helper/form-date-time-local/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\DateTimeLocal('my-datetime'); // Within your view... echo $this-&gt;formDateTimeLocal($element); // Result: &lt;input type=\"datetime-local\" name=\"my-datetime\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-date-time/","text":"FormDateTime The FormDateTime view helper can be used to render a &lt;input type=\"datetime\"&gt; HTML5 form input. It is meant to work with the DateTime element , which provides a default input specification for validating HTML5 datetime values. Basic usage use Laminas\\Form\\Element; $element = new Element\\DateTime('my-datetime'); // Within your view... echo $this-&gt;formDateTime($element); // Result: &lt;input type=\"datetime\" name=\"my-datetime\" value=\"\"&gt;","title":"formDateTime"},{"location":"helper/form-date-time/#formdatetime","text":"The FormDateTime view helper can be used to render a &lt;input type=\"datetime\"&gt; HTML5 form input. It is meant to work with the DateTime element , which provides a default input specification for validating HTML5 datetime values.","title":"FormDateTime"},{"location":"helper/form-date-time/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\DateTime('my-datetime'); // Within your view... echo $this-&gt;formDateTime($element); // Result: &lt;input type=\"datetime\" name=\"my-datetime\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-date/","text":"FormDate The FormDate view helper can be used to render a &lt;input type=\"date\"&gt; HTML5 form input. It is meant to work with the date element , which provides a default input specification for validating HTML5 date values. FormDate extends from the FormDateTime helper . Basic usage use Laminas\\Form\\Element; $element = new Element\\Date('my-date'); // Within your view... echo $this-&gt;formDate($element); // Result: &lt;input type=\"date\" name=\"my-date\" value=\"\"&gt;","title":"formDate"},{"location":"helper/form-date/#formdate","text":"The FormDate view helper can be used to render a &lt;input type=\"date\"&gt; HTML5 form input. It is meant to work with the date element , which provides a default input specification for validating HTML5 date values. FormDate extends from the FormDateTime helper .","title":"FormDate"},{"location":"helper/form-date/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Date('my-date'); // Within your view... echo $this-&gt;formDate($element); // Result: &lt;input type=\"date\" name=\"my-date\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-element-errors/","text":"FormElementErrors The FormElementErrors view helper is used to render the validation error messages of an element. Basic usage use Laminas\\Form\\Form; use Laminas\\Form\\Element; use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\Input; // Create a form $form = new Form(); $element = new Element\\Text('my-text'); $form-&gt;add($element); // Create a input $input = new Input('my-text'); $input-&gt;setRequired(true); $inputFilter = new InputFilter(); $inputFilter-&gt;add($input); $form-&gt;setInputFilter($inputFilter); // Force a failure $form-&gt;setData(array()); // Empty data $form-&gt;isValid(); // Not valid // Within your view... /** * Example #1: Default options */ echo $this-&gt;formElementErrors($element); // Result: &lt;ul&gt;&lt;li&gt;Value is required and can&#039;t be empty&lt;/li&gt;&lt;/ul&gt; /** * Example #2: Add attributes to open format */ echo $this-&gt;formElementErrors($element, ['class' =&gt; 'help-inline']); // Result: // &lt;ul class=\"help-inline\"&gt;&lt;li&gt;Value is required and can&#039;t be empty&lt;/li&gt;&lt;/ul&gt; /** * Example #3: Custom format */ $helper = $this-&gt;formElementErrors(); $helper-&gt;setMessageOpenFormat('&lt;div class=\"help-inline\"&gt;'); $helper-&gt;setMessageSeparatorString('&lt;/div&gt;&lt;div class=\"help-inline\"&gt;'); $helper-&gt;setMessageCloseString('&lt;/div&gt;'); echo $helper-&gt;render($element); // Result: &lt;div class=\"help-inline\"&gt;Value is required and can&#039;t be empty&lt;/div&gt; Public methods The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description setMessageOpenFormat(string $messageOpenFormat) : void Set the ( printf ) formatted string used to open message representation; uses &lt;ul%s&gt;&lt;li&gt; by default; attributes are inserted for the placeholder. getMessageOpenFormat() : string Returns the formatted string used to open message representation. setMessageSeparatorString(string $messageSeparatorString) : string Sets the string used to separate messages; defaults to &lt;/li&gt;&lt;li&gt; . getMessageSeparatorString() : string Returns the string used to separate messages. setMessageCloseString(string $messageCloseString) : void Sets the string used to close message representation; defaults to &lt;/li&gt;&lt;/ul&gt; . getMessageCloseString() : string Returns the string used to close message representation. setAttributes(array $attributes) : void Set the attributes that will go on the message open format as key/value pairs. getAttributes() : array Returns the attributes that will go on the message open format. setTranslateMessages(bool $flag) : self Indicate whether or not element validation error messages should be translated during render() . Default is to translate them. render(ElementInterface $element [, array $attributes = array()]) : string Renders validation errors for the provided $element . Attributes provided will be used in the messageOpenFormat , and merged with any provided previously via setAttributes() .","title":"formElementErrors"},{"location":"helper/form-element-errors/#formelementerrors","text":"The FormElementErrors view helper is used to render the validation error messages of an element.","title":"FormElementErrors"},{"location":"helper/form-element-errors/#basic-usage","text":"use Laminas\\Form\\Form; use Laminas\\Form\\Element; use Laminas\\InputFilter\\InputFilter; use Laminas\\InputFilter\\Input; // Create a form $form = new Form(); $element = new Element\\Text('my-text'); $form-&gt;add($element); // Create a input $input = new Input('my-text'); $input-&gt;setRequired(true); $inputFilter = new InputFilter(); $inputFilter-&gt;add($input); $form-&gt;setInputFilter($inputFilter); // Force a failure $form-&gt;setData(array()); // Empty data $form-&gt;isValid(); // Not valid // Within your view... /** * Example #1: Default options */ echo $this-&gt;formElementErrors($element); // Result: &lt;ul&gt;&lt;li&gt;Value is required and can&#039;t be empty&lt;/li&gt;&lt;/ul&gt; /** * Example #2: Add attributes to open format */ echo $this-&gt;formElementErrors($element, ['class' =&gt; 'help-inline']); // Result: // &lt;ul class=\"help-inline\"&gt;&lt;li&gt;Value is required and can&#039;t be empty&lt;/li&gt;&lt;/ul&gt; /** * Example #3: Custom format */ $helper = $this-&gt;formElementErrors(); $helper-&gt;setMessageOpenFormat('&lt;div class=\"help-inline\"&gt;'); $helper-&gt;setMessageSeparatorString('&lt;/div&gt;&lt;div class=\"help-inline\"&gt;'); $helper-&gt;setMessageCloseString('&lt;/div&gt;'); echo $helper-&gt;render($element); // Result: &lt;div class=\"help-inline\"&gt;Value is required and can&#039;t be empty&lt;/div&gt;","title":"Basic usage"},{"location":"helper/form-element-errors/#public-methods","text":"The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description setMessageOpenFormat(string $messageOpenFormat) : void Set the ( printf ) formatted string used to open message representation; uses &lt;ul%s&gt;&lt;li&gt; by default; attributes are inserted for the placeholder. getMessageOpenFormat() : string Returns the formatted string used to open message representation. setMessageSeparatorString(string $messageSeparatorString) : string Sets the string used to separate messages; defaults to &lt;/li&gt;&lt;li&gt; . getMessageSeparatorString() : string Returns the string used to separate messages. setMessageCloseString(string $messageCloseString) : void Sets the string used to close message representation; defaults to &lt;/li&gt;&lt;/ul&gt; . getMessageCloseString() : string Returns the string used to close message representation. setAttributes(array $attributes) : void Set the attributes that will go on the message open format as key/value pairs. getAttributes() : array Returns the attributes that will go on the message open format. setTranslateMessages(bool $flag) : self Indicate whether or not element validation error messages should be translated during render() . Default is to translate them. render(ElementInterface $element [, array $attributes = array()]) : string Renders validation errors for the provided $element . Attributes provided will be used in the messageOpenFormat , and merged with any provided previously via setAttributes() .","title":"Public methods"},{"location":"helper/form-element/","text":"FormElement The FormElement view helper proxies the rendering to specific form view helpers depending on the type of the Laminas\\Form\\Element provided. For instance, if the provided element had a type of \"text\", the FormElement helper will retrieve and use the FormText helper to render the element. Basic usage: use Laminas\\Form\\Form; use Laminas\\Form\\Element; // Within your view... /** * Example #1: Render different types of form elements */ $textElement = new Element\\Text('my-text'); $checkboxElement = new Element\\Checkbox('my-checkbox'); echo $this-&gt;formElement($textElement); // Result: &lt;input type=\"text\" name=\"my-text\" value=\"\"&gt; echo $this-&gt;formElement($checkboxElement); // Result: // &lt;input type=\"hidden\" name=\"my-checkbox\" value=\"0\"&gt; // &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"1\"&gt; /** * Example #2: Loop through form elements and render them */ $form = new Form(); // ...add elements and input filter to form... $form-&gt;prepare(); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); // ...loop through and render the form elements... foreach ($form as $element) { echo $this-&gt;formElement($element); echo $this-&gt;formElementErrors($element); } // Render the closing tag echo $this-&gt;form()-&gt;closeTag();","title":"formElement"},{"location":"helper/form-element/#formelement","text":"The FormElement view helper proxies the rendering to specific form view helpers depending on the type of the Laminas\\Form\\Element provided. For instance, if the provided element had a type of \"text\", the FormElement helper will retrieve and use the FormText helper to render the element.","title":"FormElement"},{"location":"helper/form-element/#basic-usage","text":"use Laminas\\Form\\Form; use Laminas\\Form\\Element; // Within your view... /** * Example #1: Render different types of form elements */ $textElement = new Element\\Text('my-text'); $checkboxElement = new Element\\Checkbox('my-checkbox'); echo $this-&gt;formElement($textElement); // Result: &lt;input type=\"text\" name=\"my-text\" value=\"\"&gt; echo $this-&gt;formElement($checkboxElement); // Result: // &lt;input type=\"hidden\" name=\"my-checkbox\" value=\"0\"&gt; // &lt;input type=\"checkbox\" name=\"my-checkbox\" value=\"1\"&gt; /** * Example #2: Loop through form elements and render them */ $form = new Form(); // ...add elements and input filter to form... $form-&gt;prepare(); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); // ...loop through and render the form elements... foreach ($form as $element) { echo $this-&gt;formElement($element); echo $this-&gt;formElementErrors($element); } // Render the closing tag echo $this-&gt;form()-&gt;closeTag();","title":"Basic usage:"},{"location":"helper/form-email/","text":"FormEmail The FormEmail view helper can be used to render a &lt;input type=\"email\"&gt; HTML5 form input. It is meant to work with the Email element , which provides a default input specification with an email validator. Basic usage use Laminas\\Form\\Element; $element = new Element\\Email('my-email'); // Within your view... echo $this-&gt;formEmail($element); // Result: &lt;input type=\"email\" name=\"my-email\" value=\"\"&gt;","title":"formEmail"},{"location":"helper/form-email/#formemail","text":"The FormEmail view helper can be used to render a &lt;input type=\"email\"&gt; HTML5 form input. It is meant to work with the Email element , which provides a default input specification with an email validator.","title":"FormEmail"},{"location":"helper/form-email/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Email('my-email'); // Within your view... echo $this-&gt;formEmail($element); // Result: &lt;input type=\"email\" name=\"my-email\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-file-apc-progress/","text":"FormFileApcProgress The FormFileApcProgress view helper can be used to render a &lt;input type=\"hidden\" ...&gt; with a progress ID value used by the APC File Upload Progress feature. The APC PHP module is required for this view helper to work. Unlike other Form view helpers, the FormFileSessionProgress helper does not accept an Element as a parameter. An id attribute with a value of \"progress_key\" will automatically be added. Render early The view helper must be rendered before the file input in the form, or upload progress will not work correctly. Best used with the Laminas\\ProgressBar\\Upload\\ApcProgress handler. See the apc.rfc1867 ini setting in the APC Configuration documentation for more information. Basic usage // Within your view... echo $this-&gt;formFileApcProgress(); // Result: &lt;input type=\"hidden\" id=\"progress_key\" name=\"APC_UPLOAD_PROGRESS\" value=\"12345abcde\"&gt;","title":"formFileApcProgress"},{"location":"helper/form-file-apc-progress/#formfileapcprogress","text":"The FormFileApcProgress view helper can be used to render a &lt;input type=\"hidden\" ...&gt; with a progress ID value used by the APC File Upload Progress feature. The APC PHP module is required for this view helper to work. Unlike other Form view helpers, the FormFileSessionProgress helper does not accept an Element as a parameter. An id attribute with a value of \"progress_key\" will automatically be added.","title":"FormFileApcProgress"},{"location":"helper/form-file-apc-progress/#basic-usage","text":"// Within your view... echo $this-&gt;formFileApcProgress(); // Result: &lt;input type=\"hidden\" id=\"progress_key\" name=\"APC_UPLOAD_PROGRESS\" value=\"12345abcde\"&gt;","title":"Basic usage"},{"location":"helper/form-file-session-progress/","text":"FormFileSessionProgress The FormFileSessionProgress view helper can be used to render a &lt;input type=\"hidden\" ...&gt; which can be used by the PHP 5.4+ File Upload Session Progress feature.Unlike other laminas-form view helpers, the FormFileSessionProgress helper does not accept an Element as a parameter. An id attribute with a value of \"progress_key\" will automatically be added. Render early The view helper must be rendered before the file input in the form, or upload progress will not work correctly. Best used with the Laminas\\ProgressBar\\Upload\\SessionProgress handler. See the Session Upload Progress chapter in the PHP documentation for more information. Basic usage // Within your view... echo $this-&gt;formFileSessionProgress(); // Result: &lt;input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\"&gt;","title":"formFileSessionProgress"},{"location":"helper/form-file-session-progress/#formfilesessionprogress","text":"The FormFileSessionProgress view helper can be used to render a &lt;input type=\"hidden\" ...&gt; which can be used by the PHP 5.4+ File Upload Session Progress feature.Unlike other laminas-form view helpers, the FormFileSessionProgress helper does not accept an Element as a parameter. An id attribute with a value of \"progress_key\" will automatically be added.","title":"FormFileSessionProgress"},{"location":"helper/form-file-session-progress/#basic-usage","text":"// Within your view... echo $this-&gt;formFileSessionProgress(); // Result: &lt;input type=\"hidden\" id=\"progress_key\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"12345abcde\"&gt;","title":"Basic usage"},{"location":"helper/form-file-upload-progress/","text":"FormFileUploadProgress The FormFileUploadProgress view helper can be used to render an &lt;input type=\"hidden\" ...&gt; containing the upload progress token, and which can be used by the PECL uploadprogress extension. Unlike other laminas-form view helpers, the FormFileUploadProgress helper does not accept an Element as a parameter. An id attribute with a value of progress_key will automatically be added. Render early The view helper must be rendered before the file input in the form, or upload progress will not work correctly. This element should be used with the Laminas\\ProgressBar\\Upload\\UploadProgress handler. See the PECL uploadprogress extension for more information. Basic usage // Within your view... echo $this-&gt;formFileSessionProgress(); // Result &lt;input type=\"hidden\" id=\"progress_key\" name=\"UPLOAD_IDENTIFIER\" value=\"12345abcde\"&gt;","title":"formFileUploadProgress"},{"location":"helper/form-file-upload-progress/#formfileuploadprogress","text":"The FormFileUploadProgress view helper can be used to render an &lt;input type=\"hidden\" ...&gt; containing the upload progress token, and which can be used by the PECL uploadprogress extension. Unlike other laminas-form view helpers, the FormFileUploadProgress helper does not accept an Element as a parameter. An id attribute with a value of progress_key will automatically be added.","title":"FormFileUploadProgress"},{"location":"helper/form-file-upload-progress/#basic-usage","text":"// Within your view... echo $this-&gt;formFileSessionProgress(); // Result &lt;input type=\"hidden\" id=\"progress_key\" name=\"UPLOAD_IDENTIFIER\" value=\"12345abcde\"&gt;","title":"Basic usage"},{"location":"helper/form-file/","text":"FormFile The FormFile view helper can be used to render an &lt;input type=\"file\"&gt; form input. It is meant to work with the File element . Basic usage use Laminas\\Form\\Element; $element = new Element\\File('my-file'); // Within your view... echo $this-&gt;formFile($element); // Result: &lt;input type=\"file\" name=\"my-file\"&gt; For HTML5 multiple file uploads, the multiple attribute can be used. Browsers that do not support HTML5 will default to a single upload input. use Laminas\\Form\\Element; $element = new Element\\File('my-file'); $element-&gt;setAttribute('multiple', true); // Within your view... echo $this-&gt;formFile($element); // Result: &lt;input type=\"file\" name=\"my-file\" multiple=\"multiple\"&gt;","title":"formFile"},{"location":"helper/form-file/#formfile","text":"The FormFile view helper can be used to render an &lt;input type=\"file\"&gt; form input. It is meant to work with the File element .","title":"FormFile"},{"location":"helper/form-file/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\File('my-file'); // Within your view... echo $this-&gt;formFile($element); // Result: &lt;input type=\"file\" name=\"my-file\"&gt; For HTML5 multiple file uploads, the multiple attribute can be used. Browsers that do not support HTML5 will default to a single upload input. use Laminas\\Form\\Element; $element = new Element\\File('my-file'); $element-&gt;setAttribute('multiple', true); // Within your view... echo $this-&gt;formFile($element); // Result: &lt;input type=\"file\" name=\"my-file\" multiple=\"multiple\"&gt;","title":"Basic usage"},{"location":"helper/form-hidden/","text":"FormHidden The FormHidden view helper can be used to render an &lt;input type=\"hidden\"&gt; HTML form input. It is meant to work with the Hidden element . Basic usage use Laminas\\Form\\Element; $element = new Element\\Hidden('my-hidden'); $element-&gt;setValue('foo'); // Within your view... echo $this-&gt;formHidden($element); // Result: &lt;input type=\"hidden\" name=\"my-hidden\" value=\"foo\"&gt;","title":"formHidden"},{"location":"helper/form-hidden/#formhidden","text":"The FormHidden view helper can be used to render an &lt;input type=\"hidden\"&gt; HTML form input. It is meant to work with the Hidden element .","title":"FormHidden"},{"location":"helper/form-hidden/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Hidden('my-hidden'); $element-&gt;setValue('foo'); // Within your view... echo $this-&gt;formHidden($element); // Result: &lt;input type=\"hidden\" name=\"my-hidden\" value=\"foo\"&gt;","title":"Basic usage"},{"location":"helper/form-image/","text":"FormImage The FormImage view helper can be used to render an &lt;input type=\"image\"&gt; HTML form input. It is meant to work with the Image element . Basic usage use Laminas\\Form\\Element; $element = new Element\\Image('my-image'); $element-&gt;setAttribute('src', '/img/my-pic.png'); // Within your view... echo $this-&gt;formImage($element); // Result: &lt;input type=\"image\" name=\"my-image\" src=\"/img/my-pic.png\"&gt;","title":"formImage"},{"location":"helper/form-image/#formimage","text":"The FormImage view helper can be used to render an &lt;input type=\"image\"&gt; HTML form input. It is meant to work with the Image element .","title":"FormImage"},{"location":"helper/form-image/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Image('my-image'); $element-&gt;setAttribute('src', '/img/my-pic.png'); // Within your view... echo $this-&gt;formImage($element); // Result: &lt;input type=\"image\" name=\"my-image\" src=\"/img/my-pic.png\"&gt;","title":"Basic usage"},{"location":"helper/form-input/","text":"FormInput The FormInput view helper is used to render an &lt;input&gt; HTML form input tag. It acts as a base class for all of the specifically typed form input helpers ( FormText , FormCheckbox , FormSubmit , etc.), and is not suggested for direct use. It contains a general map of valid tag attributes and types for attribute filtering. Each subclass of FormInput implements its own specific map of valid tag attributes. Public methods The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description render(ElementInterface $element) : string Renders the &lt;input&gt; tag for the $element .","title":"formInput"},{"location":"helper/form-input/#forminput","text":"The FormInput view helper is used to render an &lt;input&gt; HTML form input tag. It acts as a base class for all of the specifically typed form input helpers ( FormText , FormCheckbox , FormSubmit , etc.), and is not suggested for direct use. It contains a general map of valid tag attributes and types for attribute filtering. Each subclass of FormInput implements its own specific map of valid tag attributes.","title":"FormInput"},{"location":"helper/form-input/#public-methods","text":"The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description render(ElementInterface $element) : string Renders the &lt;input&gt; tag for the $element .","title":"Public methods"},{"location":"helper/form-label/","text":"FormLabel The FormLabel view helper is used to render a &lt;label&gt; HTML element and its attributes. If you have a Laminas\\I18n\\Translator\\Translator attached, FormLabel will translate the label contents when rendering. Basic usage use Laminas\\Form\\Element; $element = new Element\\Text('my-text'); $element-&gt;setLabel('Label'); $element-&gt;setAttribute('id', 'text-id'); $element-&gt;setLabelAttributes(['class' =&gt; 'control-label']); // Within your view... /** * Example #1: Render label in one shot */ echo $this-&gt;formLabel($element); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt;Label&lt;/label&gt; echo $this-&gt;formLabel($element, $this-&gt;formText($element)); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt;Label&lt;input type=\"text\" name=\"my-text\"&gt;&lt;/label&gt; echo $this-&gt;formLabel($element, $this-&gt;formText($element), 'append'); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt;&lt;input type=\"text\" name=\"my-text\"&gt;Label&lt;/label&gt; /** * Example #2: Render label in separate steps */ // Render the opening tag echo $this-&gt;formLabel()-&gt;openTag($element); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt; // Render the closing tag echo $this-&gt;formLabel()-&gt;closeTag(); // Result: &lt;/label&gt; /** * Example #3: Render html label after toggling off escape */ $element-&gt;setLabel('&lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt;'); $element-&gt;setLabelOptions(['disable_html_escape' =&gt; true]); echo $this-&gt;formLabel($element); // Result: // &lt;label class=\"control-label\" for=\"text-id\"&gt; // &lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt; // &lt;/label&gt; Escaping HTML escaping only applies to the Element::$label property, not to the helper $labelContent parameter. Label translation See AbstractHelper Translation . Public methods The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description __invoke(ElementInterface $element = null, string $labelContent = null, string $position = null) : string Render a form label, optionally with content. Always generates a for attribute, as we cannot assume the form input will be provided in the $labelContent . If the $labelContent is null , the helper uses the element's label value. $position is used to indicate where the label element should be rendered, and should be one of FormLabel::APPEND or FormLabel::PREPEND (the default). openTag(array|ElementInterface $attributesOrElement = null) : string Renders the &lt;label&gt; open tag and attributes. $attributesOrElement should be an array of key/value pairs representing label attributes, or an ElementInterface instance. closeTag() : string Renders a &lt;/label&gt; closing tag.","title":"formLabel"},{"location":"helper/form-label/#formlabel","text":"The FormLabel view helper is used to render a &lt;label&gt; HTML element and its attributes. If you have a Laminas\\I18n\\Translator\\Translator attached, FormLabel will translate the label contents when rendering.","title":"FormLabel"},{"location":"helper/form-label/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Text('my-text'); $element-&gt;setLabel('Label'); $element-&gt;setAttribute('id', 'text-id'); $element-&gt;setLabelAttributes(['class' =&gt; 'control-label']); // Within your view... /** * Example #1: Render label in one shot */ echo $this-&gt;formLabel($element); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt;Label&lt;/label&gt; echo $this-&gt;formLabel($element, $this-&gt;formText($element)); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt;Label&lt;input type=\"text\" name=\"my-text\"&gt;&lt;/label&gt; echo $this-&gt;formLabel($element, $this-&gt;formText($element), 'append'); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt;&lt;input type=\"text\" name=\"my-text\"&gt;Label&lt;/label&gt; /** * Example #2: Render label in separate steps */ // Render the opening tag echo $this-&gt;formLabel()-&gt;openTag($element); // Result: &lt;label class=\"control-label\" for=\"text-id\"&gt; // Render the closing tag echo $this-&gt;formLabel()-&gt;closeTag(); // Result: &lt;/label&gt; /** * Example #3: Render html label after toggling off escape */ $element-&gt;setLabel('&lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt;'); $element-&gt;setLabelOptions(['disable_html_escape' =&gt; true]); echo $this-&gt;formLabel($element); // Result: // &lt;label class=\"control-label\" for=\"text-id\"&gt; // &lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt; // &lt;/label&gt;","title":"Basic usage"},{"location":"helper/form-label/#label-translation","text":"See AbstractHelper Translation .","title":"Label translation"},{"location":"helper/form-label/#public-methods","text":"The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description __invoke(ElementInterface $element = null, string $labelContent = null, string $position = null) : string Render a form label, optionally with content. Always generates a for attribute, as we cannot assume the form input will be provided in the $labelContent . If the $labelContent is null , the helper uses the element's label value. $position is used to indicate where the label element should be rendered, and should be one of FormLabel::APPEND or FormLabel::PREPEND (the default). openTag(array|ElementInterface $attributesOrElement = null) : string Renders the &lt;label&gt; open tag and attributes. $attributesOrElement should be an array of key/value pairs representing label attributes, or an ElementInterface instance. closeTag() : string Renders a &lt;/label&gt; closing tag.","title":"Public methods"},{"location":"helper/form-month-select/","text":"FormMonthSelect The FormMonthSelect view helper renders two select elements, one with a list of months, another with a list of years. It works in conjection with the MonthSelect element, which provides the data for the selects, as well as validation around input provided by them. Basic usage use Laminas\\Form\\Element; $monthYear = new Element\\MonthSelect('monthyear'); $monthYear-&gt;setLabel('Select a month and a year'); $monthYear-&gt;setMinYear(1986); // Within your view... echo $this-&gt;formMonthSelect($monthYear); // Result: // &lt;select name=\"monthyear[month]\"&gt; ... &lt;/select&gt; // &lt;select name=\"monthyear[year]\"&gt; ... &lt;/select&gt;","title":"formMonthSelect"},{"location":"helper/form-month-select/#formmonthselect","text":"The FormMonthSelect view helper renders two select elements, one with a list of months, another with a list of years. It works in conjection with the MonthSelect element, which provides the data for the selects, as well as validation around input provided by them.","title":"FormMonthSelect"},{"location":"helper/form-month-select/#basic-usage","text":"use Laminas\\Form\\Element; $monthYear = new Element\\MonthSelect('monthyear'); $monthYear-&gt;setLabel('Select a month and a year'); $monthYear-&gt;setMinYear(1986); // Within your view... echo $this-&gt;formMonthSelect($monthYear); // Result: // &lt;select name=\"monthyear[month]\"&gt; ... &lt;/select&gt; // &lt;select name=\"monthyear[year]\"&gt; ... &lt;/select&gt;","title":"Basic usage"},{"location":"helper/form-month/","text":"FormMonth The FormMonth view helper can be used to render an &lt;input type=\"month\"&gt; HTML5 form input. It is meant to work with the Month element , which provides a default input specification for validating HTML5 date values. FormMonth extends from FormDateTime . Basic usage use Laminas\\Form\\Element; $element = new Element\\Month('my-month'); // Within your view... echo $this-&gt;formMonth($element); // Result: &lt;input type=\"month\" name=\"my-month\" value=\"\"&gt;","title":"formMonth"},{"location":"helper/form-month/#formmonth","text":"The FormMonth view helper can be used to render an &lt;input type=\"month\"&gt; HTML5 form input. It is meant to work with the Month element , which provides a default input specification for validating HTML5 date values. FormMonth extends from FormDateTime .","title":"FormMonth"},{"location":"helper/form-month/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Month('my-month'); // Within your view... echo $this-&gt;formMonth($element); // Result: &lt;input type=\"month\" name=\"my-month\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-multicheckbox/","text":"FormMultiCheckbox The FormMultiCheckbox view helper can be used to render a group of &lt;input type=\"checkbox\"&gt; HTML form inputs. It is meant to work with the MultiCheckbox element , which provides a default input specification for validating checkbox groups. Basic usage use Laminas\\Form\\Element; $element = new Element\\MultiCheckbox('my-multicheckbox'); $element-&gt;setValueOptions([ '0' =&gt; 'Apple', '1' =&gt; 'Orange', '2' =&gt; 'Lemon', ]); // Within your view... /** * Example #1: using the default label placement */ echo $this-&gt;formMultiCheckbox($element); // Result: // &lt;label&gt;&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\"&gt;Apple&lt;/label&gt; // &lt;label&gt;&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\"&gt;Orange&lt;/label&gt; // &lt;label&gt;&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\"&gt;Lemon&lt;/label&gt; /** * Example #2: using the prepend label placement */ echo $this-&gt;formMultiCheckbox($element, 'prepend'); // Result: // &lt;label&gt;Apple&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\"&gt;&lt;/label&gt; // &lt;label&gt;Orange&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\"&gt;&lt;/label&gt; // &lt;label&gt;Lemon&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\"&gt;&lt;/label&gt;","title":"formMultiCheckbox"},{"location":"helper/form-multicheckbox/#formmulticheckbox","text":"The FormMultiCheckbox view helper can be used to render a group of &lt;input type=\"checkbox\"&gt; HTML form inputs. It is meant to work with the MultiCheckbox element , which provides a default input specification for validating checkbox groups.","title":"FormMultiCheckbox"},{"location":"helper/form-multicheckbox/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\MultiCheckbox('my-multicheckbox'); $element-&gt;setValueOptions([ '0' =&gt; 'Apple', '1' =&gt; 'Orange', '2' =&gt; 'Lemon', ]); // Within your view... /** * Example #1: using the default label placement */ echo $this-&gt;formMultiCheckbox($element); // Result: // &lt;label&gt;&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\"&gt;Apple&lt;/label&gt; // &lt;label&gt;&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\"&gt;Orange&lt;/label&gt; // &lt;label&gt;&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\"&gt;Lemon&lt;/label&gt; /** * Example #2: using the prepend label placement */ echo $this-&gt;formMultiCheckbox($element, 'prepend'); // Result: // &lt;label&gt;Apple&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"0\"&gt;&lt;/label&gt; // &lt;label&gt;Orange&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"1\"&gt;&lt;/label&gt; // &lt;label&gt;Lemon&lt;input type=\"checkbox\" name=\"my-multicheckbox[]\" value=\"2\"&gt;&lt;/label&gt;","title":"Basic usage"},{"location":"helper/form-number/","text":"FormNumber The FormNumber view helper can be used to render an &lt;input type=\"number\"&gt; HTML form input. It is meant to work with the Number element , which provides a default input specification for validating numerical values. Basic usage use Laminas\\Form\\Element; $element = new Element\\Number('my-number'); // Within your view... echo $this-&gt;formNumber($element); Output: &lt;input type=\"number\" name=\"my-number\" value=\"\"&gt; Usage of min , max and step attributes: use Laminas\\Form\\Element; $element = new Element\\Number('my-number'); $element-&gt;setAttributes([ 'min' =&gt; 5, 'max' =&gt; 20, 'step' =&gt; 0.5, ]); $element-&gt;setValue(12); // Within your view... echo $this-&gt;formNumber($element); Output: &lt;input type=\"number\" name=\"my-number\" min=\"5\" max=\"20\" step=\"0.5\" value=\"12\"&gt;","title":"formNumber"},{"location":"helper/form-number/#formnumber","text":"The FormNumber view helper can be used to render an &lt;input type=\"number\"&gt; HTML form input. It is meant to work with the Number element , which provides a default input specification for validating numerical values.","title":"FormNumber"},{"location":"helper/form-number/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Number('my-number'); // Within your view... echo $this-&gt;formNumber($element); Output: &lt;input type=\"number\" name=\"my-number\" value=\"\"&gt; Usage of min , max and step attributes: use Laminas\\Form\\Element; $element = new Element\\Number('my-number'); $element-&gt;setAttributes([ 'min' =&gt; 5, 'max' =&gt; 20, 'step' =&gt; 0.5, ]); $element-&gt;setValue(12); // Within your view... echo $this-&gt;formNumber($element); Output: &lt;input type=\"number\" name=\"my-number\" min=\"5\" max=\"20\" step=\"0.5\" value=\"12\"&gt;","title":"Basic usage"},{"location":"helper/form-password/","text":"FormPassword The FormPassword view helper can be used to render an &lt;input type=\"password\"&gt; HTML form input. It is meant to work with the Password element . Basic usage use Laminas\\Form\\Element; $element = new Element\\Password('my-password'); // Within your view... echo $this-&gt;formPassword($element); Output: &lt;input type=\"password\" name=\"my-password\" value=\"\"&gt;","title":"formPassword"},{"location":"helper/form-password/#formpassword","text":"The FormPassword view helper can be used to render an &lt;input type=\"password\"&gt; HTML form input. It is meant to work with the Password element .","title":"FormPassword"},{"location":"helper/form-password/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Password('my-password'); // Within your view... echo $this-&gt;formPassword($element); Output: &lt;input type=\"password\" name=\"my-password\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-radio/","text":"FormRadio The FormRadio view helper can be used to render a group of &lt;input type=\"radio\"&gt; HTML form inputs. It is meant to work with the Radio element , which provides a default input specification for validating a radio. FormRadio extends from FormMultiCheckbox . Basic usage use Laminas\\Form\\Element; $element = new Element\\Radio('likes_chocolate'); $element-&gt;setValueOptions([ '0' =&gt; 'No', '1' =&gt; 'Yes', ]); // Within your view... /** * Example #1: using the default label placement */ echo $this-&gt;formRadio($element); // Result: // &lt;label&gt;&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\"&gt;No&lt;/label&gt; // &lt;label&gt;&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\"&gt;Yes&lt;/label&gt; /** * Example #2: using the prepend label placement */ echo $this-&gt;formRadio($element, 'prepend'); // Result: // &lt;label&gt;No&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\"&gt;&lt;/label&gt; // &lt;label&gt;Yes&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\"&gt;&lt;/label&gt;","title":"formRadio"},{"location":"helper/form-radio/#formradio","text":"The FormRadio view helper can be used to render a group of &lt;input type=\"radio\"&gt; HTML form inputs. It is meant to work with the Radio element , which provides a default input specification for validating a radio. FormRadio extends from FormMultiCheckbox .","title":"FormRadio"},{"location":"helper/form-radio/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Radio('likes_chocolate'); $element-&gt;setValueOptions([ '0' =&gt; 'No', '1' =&gt; 'Yes', ]); // Within your view... /** * Example #1: using the default label placement */ echo $this-&gt;formRadio($element); // Result: // &lt;label&gt;&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\"&gt;No&lt;/label&gt; // &lt;label&gt;&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\"&gt;Yes&lt;/label&gt; /** * Example #2: using the prepend label placement */ echo $this-&gt;formRadio($element, 'prepend'); // Result: // &lt;label&gt;No&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"0\"&gt;&lt;/label&gt; // &lt;label&gt;Yes&lt;input type=\"radio\" name=\"likes_chocolate[]\" value=\"1\"&gt;&lt;/label&gt;","title":"Basic usage"},{"location":"helper/form-range/","text":"FormRange The FormRange view helper can be used to render an &lt;input type=\"range\"&gt; HTML form input. It is meant to work with the Range element , which provides a default input specification for validating numerical ranges. Basic usage use Laminas\\Form\\Element; $element = new Element\\Range('my-range'); // Within your view... echo $this-&gt;formRange($element); Output: &lt;input type=\"range\" name=\"my-range\" value=\"\"&gt; Usage of min , max and step attributes: use Laminas\\Form\\Element; $element = new Element\\Range('my-range'); $element-&gt;setAttributes([ 'min' =&gt; 0, 'max' =&gt; 100, 'step' =&gt; 5, ]); $element-&gt;setValue(20); // Within your view... echo $this-&gt;formRange($element); Output: &lt;input type=\"range\" name=\"my-range\" min=\"0\" max=\"100\" step=\"5\" value=\"20\"&gt;","title":"formRange"},{"location":"helper/form-range/#formrange","text":"The FormRange view helper can be used to render an &lt;input type=\"range\"&gt; HTML form input. It is meant to work with the Range element , which provides a default input specification for validating numerical ranges.","title":"FormRange"},{"location":"helper/form-range/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Range('my-range'); // Within your view... echo $this-&gt;formRange($element); Output: &lt;input type=\"range\" name=\"my-range\" value=\"\"&gt; Usage of min , max and step attributes: use Laminas\\Form\\Element; $element = new Element\\Range('my-range'); $element-&gt;setAttributes([ 'min' =&gt; 0, 'max' =&gt; 100, 'step' =&gt; 5, ]); $element-&gt;setValue(20); // Within your view... echo $this-&gt;formRange($element); Output: &lt;input type=\"range\" name=\"my-range\" min=\"0\" max=\"100\" step=\"5\" value=\"20\"&gt;","title":"Basic usage"},{"location":"helper/form-reset/","text":"FormReset The FormReset view helper can be used to render an &lt;input type=\"reset\"&gt; HTML form input. Basic usage use Laminas\\Form\\Element; $element = new Element('my-reset'); $element-&gt;setAttribute('value', 'Reset'); // Within your view... echo $this-&gt;formReset($element); Output: &lt;input type=\"reset\" name=\"my-reset\" value=\"Reset\"&gt;","title":"formReset"},{"location":"helper/form-reset/#formreset","text":"The FormReset view helper can be used to render an &lt;input type=\"reset\"&gt; HTML form input.","title":"FormReset"},{"location":"helper/form-reset/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element('my-reset'); $element-&gt;setAttribute('value', 'Reset'); // Within your view... echo $this-&gt;formReset($element); Output: &lt;input type=\"reset\" name=\"my-reset\" value=\"Reset\"&gt;","title":"Basic usage"},{"location":"helper/form-row/","text":"FormRow The FormRow view helper is used by Form view helper to render each row of a form, but can also be used stand-alone. A form row usually consists of the output produced by the helper specific to an input, plus its label and errors, if any. FormRow handles different rendering options, having elements wrapped by the &lt;label\\&gt; HTML block by default, but also allowing to render them in separate blocks when the element has an id attribute specified, thus preserving browser usability features. Other options involve label positioning, escaping, toggling errors and using custom partial templates. Basic Usage /** * inside view template * * @var \\Laminas\\View\\Renderer\\PhpRenderer $this * @var \\Laminas\\Form\\Form $form */ // Prepare the form $form-&gt;prepare(); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); $element = $form-&gt;get('some_element'); $element-&gt;setLabel('Some Label'); // Render 'some_element' label, input, and errors if any: echo $this-&gt;formRow($element); // Result: &lt;label&gt;&lt;span&gt;Some Label&lt;/span&gt;&lt;input type=\"text\" name=\"some_element\" value=\"\"&gt;&lt;/label&gt; // Altering label position: echo $this-&gt;formRow($element, 'append'); // Result: &lt;label&gt;&lt;input type=\"text\" name=\"some_element\" value=\"\"&gt;&lt;span&gt;Some Label&lt;/span&gt;&lt;/label&gt; // Setting the 'id' attribute will result in a separated label rather than a // wrapping one: $element-&gt;setAttribute('id', 'element_id'); echo $this-&gt;formRow($element); // Result: &lt;label for=\"element_id\"&gt;Some Label&lt;/label&gt;&lt;input type=\"text\" name=\"some_element\" id=\"element_id\" value=\"\"&gt; // Turn off escaping for HTML labels: $element-&gt;setLabel('&lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt;'); $element-&gt;setLabelOptions(['disable_html_escape' =&gt; true]); // Result: // &lt;label&gt; // &lt;span&gt; // &lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt; // &lt;/span&gt; // &lt;input type=\"text\" name=\"some_element\" value=\"\"&gt; // &lt;/label&gt; // Render the closing tag echo $this-&gt;form()-&gt;closeTag(); Escaping Label content is escaped by default.","title":"formRow"},{"location":"helper/form-row/#formrow","text":"The FormRow view helper is used by Form view helper to render each row of a form, but can also be used stand-alone. A form row usually consists of the output produced by the helper specific to an input, plus its label and errors, if any. FormRow handles different rendering options, having elements wrapped by the &lt;label\\&gt; HTML block by default, but also allowing to render them in separate blocks when the element has an id attribute specified, thus preserving browser usability features. Other options involve label positioning, escaping, toggling errors and using custom partial templates.","title":"FormRow"},{"location":"helper/form-row/#basic-usage","text":"/** * inside view template * * @var \\Laminas\\View\\Renderer\\PhpRenderer $this * @var \\Laminas\\Form\\Form $form */ // Prepare the form $form-&gt;prepare(); // Render the opening tag echo $this-&gt;form()-&gt;openTag($form); $element = $form-&gt;get('some_element'); $element-&gt;setLabel('Some Label'); // Render 'some_element' label, input, and errors if any: echo $this-&gt;formRow($element); // Result: &lt;label&gt;&lt;span&gt;Some Label&lt;/span&gt;&lt;input type=\"text\" name=\"some_element\" value=\"\"&gt;&lt;/label&gt; // Altering label position: echo $this-&gt;formRow($element, 'append'); // Result: &lt;label&gt;&lt;input type=\"text\" name=\"some_element\" value=\"\"&gt;&lt;span&gt;Some Label&lt;/span&gt;&lt;/label&gt; // Setting the 'id' attribute will result in a separated label rather than a // wrapping one: $element-&gt;setAttribute('id', 'element_id'); echo $this-&gt;formRow($element); // Result: &lt;label for=\"element_id\"&gt;Some Label&lt;/label&gt;&lt;input type=\"text\" name=\"some_element\" id=\"element_id\" value=\"\"&gt; // Turn off escaping for HTML labels: $element-&gt;setLabel('&lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt;'); $element-&gt;setLabelOptions(['disable_html_escape' =&gt; true]); // Result: // &lt;label&gt; // &lt;span&gt; // &lt;abbr title=\"Completely Automated Public Turing test to tell Computers and Humans Apart\"&gt;CAPTCHA&lt;/abbr&gt; // &lt;/span&gt; // &lt;input type=\"text\" name=\"some_element\" value=\"\"&gt; // &lt;/label&gt; // Render the closing tag echo $this-&gt;form()-&gt;closeTag();","title":"Basic Usage"},{"location":"helper/form-search/","text":"FormSearch The FormSearch view helper can be used to render an &lt;input type=\"search\"&gt; HTML5 form input. FormSearch extends from FormText . Basic usage use Laminas\\Form\\Element; $element = new Element('my-search'); // Within your view... echo $this-&gt;formSearch($element); Output: &lt;input type=\"search\" name=\"my-search\" value=\"\"&gt;","title":"formSearch"},{"location":"helper/form-search/#formsearch","text":"The FormSearch view helper can be used to render an &lt;input type=\"search\"&gt; HTML5 form input. FormSearch extends from FormText .","title":"FormSearch"},{"location":"helper/form-search/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element('my-search'); // Within your view... echo $this-&gt;formSearch($element); Output: &lt;input type=\"search\" name=\"my-search\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-select/","text":"FormSelect The FormSelect view helper can be used to render an &lt;input type=\"select\"&gt; HTML form input with its options. It is meant to work with the Select element , which provides a default input specification for validating a select. Basic usage use Laminas\\Form\\Element; $element = new Element\\Select('language'); $element-&gt;setValueOptions([ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese' ]); // Within your view... echo $this-&gt;formSelect($element);","title":"formSelect"},{"location":"helper/form-select/#formselect","text":"The FormSelect view helper can be used to render an &lt;input type=\"select\"&gt; HTML form input with its options. It is meant to work with the Select element , which provides a default input specification for validating a select.","title":"FormSelect"},{"location":"helper/form-select/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Select('language'); $element-&gt;setValueOptions([ '0' =&gt; 'French', '1' =&gt; 'English', '2' =&gt; 'Japanese', '3' =&gt; 'Chinese' ]); // Within your view... echo $this-&gt;formSelect($element);","title":"Basic usage"},{"location":"helper/form-submit/","text":"FormSubmit The FormSubmit view helper can be used to render an &lt;input type=\"submit\"&gt; HTML form input. It is meant to work with the Submit element . Basic usage use Laminas\\Form\\Element; $element = new Element\\Submit('my-submit'); // Within your view... echo $this-&gt;formSubmit($element); Output: &lt;input type=\"submit\" name=\"my-submit\" value=\"\"&gt;","title":"formSubmit"},{"location":"helper/form-submit/#formsubmit","text":"The FormSubmit view helper can be used to render an &lt;input type=\"submit\"&gt; HTML form input. It is meant to work with the Submit element .","title":"FormSubmit"},{"location":"helper/form-submit/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Submit('my-submit'); // Within your view... echo $this-&gt;formSubmit($element); Output: &lt;input type=\"submit\" name=\"my-submit\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-tel/","text":"FormTel The FormTel view helper can be used to render an &lt;input type=\"tel\"&gt; HTML5 form input. Basic usage use Laminas\\Form\\Element; $element = new Element('my-tel'); // Within your view... echo $this-&gt;formTel($element); Output: &lt;input type=\"tel\" name=\"my-tel\" value=\"\"&gt;","title":"formTel"},{"location":"helper/form-tel/#formtel","text":"The FormTel view helper can be used to render an &lt;input type=\"tel\"&gt; HTML5 form input.","title":"FormTel"},{"location":"helper/form-tel/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element('my-tel'); // Within your view... echo $this-&gt;formTel($element); Output: &lt;input type=\"tel\" name=\"my-tel\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-text/","text":"FormText The FormText view helper can be used to render an &lt;input type=\"text\"&gt; HTML form input. It is meant to work with the Text element . Basic usage use Laminas\\Form\\Element; $element = new Element\\Text('my-text'); // Within your view... echo $this-&gt;formText($element); Output: &lt;input type=\"text\" name=\"my-text\" value=\"\"&gt;","title":"formText"},{"location":"helper/form-text/#formtext","text":"The FormText view helper can be used to render an &lt;input type=\"text\"&gt; HTML form input. It is meant to work with the Text element .","title":"FormText"},{"location":"helper/form-text/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Text('my-text'); // Within your view... echo $this-&gt;formText($element); Output: &lt;input type=\"text\" name=\"my-text\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-textarea/","text":"FormTextarea The FormTextarea view helper can be used to render a &lt;textarea&gt;&lt;/textarea&gt; HTML form input. It is meant to work with the Textarea element . Basic usage use Laminas\\Form\\Element; $element = new Element\\Textarea('my-textarea'); // Within your view... echo $this-&gt;formTextarea($element); Output: &lt;textarea name=\"my-textarea\"&gt;&lt;/textarea&gt;","title":"formTextarea"},{"location":"helper/form-textarea/#formtextarea","text":"The FormTextarea view helper can be used to render a &lt;textarea&gt;&lt;/textarea&gt; HTML form input. It is meant to work with the Textarea element .","title":"FormTextarea"},{"location":"helper/form-textarea/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Textarea('my-textarea'); // Within your view... echo $this-&gt;formTextarea($element); Output: &lt;textarea name=\"my-textarea\"&gt;&lt;/textarea&gt;","title":"Basic usage"},{"location":"helper/form-time/","text":"FormTime The FormTime view helper can be used to render an &lt;input type=\"time\"&gt; HTML5 form input. It is meant to work with the Time element , which provides a default input specification for validating HTML5 time values. FormTime extends from FormDateTime . Basic usage use Laminas\\Form\\Element; $element = new Element\\Time('my-time'); // Within your view... echo $this-&gt;formTime($element); // Result: &lt;input type=\"time\" name=\"my-time\" value=\"\"&gt;","title":"formTime"},{"location":"helper/form-time/#formtime","text":"The FormTime view helper can be used to render an &lt;input type=\"time\"&gt; HTML5 form input. It is meant to work with the Time element , which provides a default input specification for validating HTML5 time values. FormTime extends from FormDateTime .","title":"FormTime"},{"location":"helper/form-time/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Time('my-time'); // Within your view... echo $this-&gt;formTime($element); // Result: &lt;input type=\"time\" name=\"my-time\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-url/","text":"FormUrl The FormUrl view helper can be used to render an &lt;input type=\"url\"&gt; HTML form input. It is meant to work with the Url element , which provides a default input specification with an URL validator. Basic usage use Laminas\\Form\\Element; $element = new Element\\Url('my-url'); // Within your view... echo $this-&gt;formUrl($element); Output: &lt;input type=\"url\" name=\"my-url\" value=\"\"&gt; Usage of custom regular expression pattern: use Laminas\\Form\\Element; $element = new Element\\Url('my-url'); $element-&gt;setAttribute('pattern', 'https?://.+'); // Within your view... echo $this-&gt;formUrl($element); Output: &lt;input type=\"url\" name=\"my-url\" pattern=\"https?://.+\" value=\"\"&gt;","title":"formUrl"},{"location":"helper/form-url/#formurl","text":"The FormUrl view helper can be used to render an &lt;input type=\"url\"&gt; HTML form input. It is meant to work with the Url element , which provides a default input specification with an URL validator.","title":"FormUrl"},{"location":"helper/form-url/#basic-usage","text":"use Laminas\\Form\\Element; $element = new Element\\Url('my-url'); // Within your view... echo $this-&gt;formUrl($element); Output: &lt;input type=\"url\" name=\"my-url\" value=\"\"&gt; Usage of custom regular expression pattern: use Laminas\\Form\\Element; $element = new Element\\Url('my-url'); $element-&gt;setAttribute('pattern', 'https?://.+'); // Within your view... echo $this-&gt;formUrl($element); Output: &lt;input type=\"url\" name=\"my-url\" pattern=\"https?://.+\" value=\"\"&gt;","title":"Basic usage"},{"location":"helper/form-week/","text":"FormWeek The FormWeek view helper can be used to render an &lt;input type=\"week\"&gt; HTML5 form input. It is meant to work with the Week element , which provides a default input specification for validating HTML5 week values. FormWeek extends from FormDateTime . Basic usage: use Laminas\\Form\\Element; $element = new Element\\Week('my-week'); // Within your view... echo $this-&gt;formWeek($element); Output: &lt;input type=\"week\" name=\"my-week\" value=\"\"&gt; Usage of min , max and step attributes: use Laminas\\Form\\Element; $element = new Element\\Week('my-week'); $element-&gt;setAttributes([ 'min' =&gt; '2012-W01', 'max' =&gt; '2020-W01', 'step' =&gt; 2, // weeks; default step interval is 1 week ]); $element-&gt;setValue('2014-W10'); // Within your view... echo $this-&gt;formWeek($element); Output: &lt;input type=\"week\" name=\"my-week\" min=\"2012-W01\" max=\"2020-W01\" step=\"2\" value=\"2014-W10\"&gt;","title":"formWeek"},{"location":"helper/form-week/#formweek","text":"The FormWeek view helper can be used to render an &lt;input type=\"week\"&gt; HTML5 form input. It is meant to work with the Week element , which provides a default input specification for validating HTML5 week values. FormWeek extends from FormDateTime . Basic usage: use Laminas\\Form\\Element; $element = new Element\\Week('my-week'); // Within your view... echo $this-&gt;formWeek($element); Output: &lt;input type=\"week\" name=\"my-week\" value=\"\"&gt; Usage of min , max and step attributes: use Laminas\\Form\\Element; $element = new Element\\Week('my-week'); $element-&gt;setAttributes([ 'min' =&gt; '2012-W01', 'max' =&gt; '2020-W01', 'step' =&gt; 2, // weeks; default step interval is 1 week ]); $element-&gt;setValue('2014-W10'); // Within your view... echo $this-&gt;formWeek($element); Output: &lt;input type=\"week\" name=\"my-week\" min=\"2012-W01\" max=\"2020-W01\" step=\"2\" value=\"2014-W10\"&gt;","title":"FormWeek"},{"location":"helper/form/","text":"Form The Form view helper is used to render a &lt;form&gt; HTML element and its attributes. If provided a Laminas\\Form\\Form instance, it will: prepare() the instance iterate it, and: pass non-collection Laminas\\Form\\Element instances to the FormRow helper to render, and pass collections and fieldsets to the FormCollection helper to render. For more fine-grained control, us the form() helper only for emitting the opening and closing &lt;form&gt; tags, and manually use other helpers to render the individual elements and fieldsets. Basic usage /** * inside a view template * * @var \\Laminas\\View\\Renderer\\PhpRenderer $this * @var \\Laminas\\Form\\Form $form */ echo $this-&gt;form($form); might result in markup like the following: &lt;form action=\"\" method=\"POST\"&gt; &lt;label&gt; &lt;span&gt;Some Label&lt;/span&gt; &lt;input type=\"text\" name=\"some_element\" value=\"\"&gt; &lt;/label&gt; &lt;/form&gt; Public methods The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description __invoke(FormInterface $form = null) : string Prepares and renders the whole form. openTag(FormInterface $form = null) : string Renders the &lt;form&gt; open tag for the $form instance. closeTag() : string Renders a &lt;/form&gt; closing tag.","title":"form"},{"location":"helper/form/#form","text":"The Form view helper is used to render a &lt;form&gt; HTML element and its attributes. If provided a Laminas\\Form\\Form instance, it will: prepare() the instance iterate it, and: pass non-collection Laminas\\Form\\Element instances to the FormRow helper to render, and pass collections and fieldsets to the FormCollection helper to render. For more fine-grained control, us the form() helper only for emitting the opening and closing &lt;form&gt; tags, and manually use other helpers to render the individual elements and fieldsets.","title":"Form"},{"location":"helper/form/#basic-usage","text":"/** * inside a view template * * @var \\Laminas\\View\\Renderer\\PhpRenderer $this * @var \\Laminas\\Form\\Form $form */ echo $this-&gt;form($form); might result in markup like the following: &lt;form action=\"\" method=\"POST\"&gt; &lt;label&gt; &lt;span&gt;Some Label&lt;/span&gt; &lt;input type=\"text\" name=\"some_element\" value=\"\"&gt; &lt;/label&gt; &lt;/form&gt;","title":"Basic usage"},{"location":"helper/form/#public-methods","text":"The following public methods are in addition to those inherited from the AbstractHelper : Method signature Description __invoke(FormInterface $form = null) : string Prepares and renders the whole form. openTag(FormInterface $form = null) : string Renders the &lt;form&gt; open tag for the $form instance. closeTag() : string Renders a &lt;/form&gt; closing tag.","title":"Public methods"},{"location":"helper/intro/","text":"View Helpers laminas-form comes with an initial set of laminas-view helper classes for tasks such as rendering forms, rendering a text input, rendering a selection box, etc. See the view helpers documentation for more information. IDE auto-completion in templates The Laminas\\Form\\View\\HelperTrait trait can be used to provide auto-completion for modern IDEs. It defines the aliases of the view helpers in a DocBlock as @method tags. Usage In order to allow auto-completion in templates, $this variable should be type-hinted via a DocBlock at the top of your template. It is recommended that you always add the Laminas\\View\\Renderer\\PhpRenderer as the first type, so that the IDE can auto-suggest the default view helpers from laminas-view . Next, chain the HelperTrait from laminas-form with a pipe symbol (a.k.a. vertical bar) | : /** * @var Laminas\\View\\Renderer\\PhpRenderer|Laminas\\Form\\View\\HelperTrait $this */ You may chain as many HelperTrait traits as you like, depending on view helpers from which Laminas component you are using and would like to provide auto-completion for.","title":"Introduction"},{"location":"helper/intro/#view-helpers","text":"laminas-form comes with an initial set of laminas-view helper classes for tasks such as rendering forms, rendering a text input, rendering a selection box, etc. See the view helpers documentation for more information.","title":"View Helpers"},{"location":"helper/upload-progress-helpers/","text":"Upload Progress Helpers laminas-form provides several helpers to use in conjunction with laminas-progressbar for the puproses of rending upload progress information. These include: FormFileApcProgress , which works with the APC extension. FormFileSessionProgress , which works with the built-in support via the session extension. FormFileUploadProgress , which works with the UploadProgress extension.","title":"Introduction"},{"location":"helper/upload-progress-helpers/#upload-progress-helpers","text":"laminas-form provides several helpers to use in conjunction with laminas-progressbar for the puproses of rending upload progress information. These include: FormFileApcProgress , which works with the APC extension. FormFileSessionProgress , which works with the built-in support via the session extension. FormFileUploadProgress , which works with the UploadProgress extension.","title":"Upload Progress Helpers"}]}